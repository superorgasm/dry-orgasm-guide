<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="robots" content="noindex, nofollow" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid rgba(255, 255, 255, 0.08);
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
                position: relative;
                z-index: 1;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: rgba(18, 18, 31, 0.92);
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 40px rgba(0, 0, 0, 0.6), 0 0 80px rgba(255, 215, 0, 0.03);
                border-radius: 8px;
                border: 1px solid rgba(255, 215, 0, 0.15);
                border-top: 3px solid #ffd700;
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box;
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px;
                width: 100%;
                color: rgba(255, 255, 255, 0.85);
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: rgba(255, 255, 255, 0.05);
                width: 100%;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                margin: 0 0 15px;
                box-sizing: border-box;
                transition: border-color 0.2s;
            }

            .staticrypt-password-container:focus-within {
                border-color: rgba(255, 215, 0, 0.4);
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
                filter: invert(1);
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #ffd700;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #0a0a12;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 4px;
                letter-spacing: 0.05em;
                transition: filter 0.2s, box-shadow 0.2s;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #ffd700;
                filter: brightness(110%);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.25);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0a0a12;
                font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                position: relative;
                overflow: hidden;
            }

            .staticrypt-bg {
                position: fixed;
                top: -30px;
                left: -30px;
                width: calc(100% + 60px);
                height: calc(100% + 60px);
                background-image: url('https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg');
                background-size: cover;
                background-position: center top;
                background-repeat: no-repeat;
                filter: blur(16px) brightness(0.2);
                z-index: 0;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
                color: #fff;
            }

            .staticrypt-site-title {
                font-size: 0.75em;
                color: #ffd700;
                margin-top: 0.3em;
                letter-spacing: 0.02em;
            }

            .staticrypt-instructions p:not(.staticrypt-title):not(.staticrypt-site-title) {
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.9em;
            }

            .staticrypt-cover-image {
                margin-bottom: 1.2em;
            }

            .staticrypt-cover-image img {
                max-width: 180px;
                width: 100%;
                height: auto;
                border-radius: 6px;
                box-shadow: 0 4px 20px rgba(255, 215, 0, 0.15);
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.85em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
                accent-color: #ffd700;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #0a0a12;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid rgba(255, 215, 0, 0.3);
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }

            @media (max-width: 600px) {
                .staticrypt-page {
                    width: 100%;
                    padding: 8% 1rem 0;
                }
                .staticrypt-form {
                    padding: 30px;
                }
                .staticrypt-cover-image img {
                    max-width: 140px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-bg"></div>
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-cover-image">
                        <img src="https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg" alt="Cover" />
                    </div>

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p class="staticrypt-site-title">ドライオーガズム6ヶ月完全開発ガイド</p>
                        <p>ガイド購入者向けページです。パスワードを入力してください。</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="パスワード"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            ログイン状態を保持（30日間）
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="認証" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "パスワードが違います",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9b7088f2012a8cfdbd0d028b132238251e0f642305af00722fb987df8ad5431ff7e6914c498f621c3be5aeb65ca0b51a1efe383125ff9709fb7b6f1084b07f64209c87ad14ed6b69d4da34736815bc2b80905719f674ed09be46e4bf9e1a1c6990889e78a27a530be218e3ccdd0cd0933aaa052070b78d901016bec467b8a789c2f65c6bb0fdedfb75aa7981c11b4855022aec1438ce1600924b1f4701f8320c661fb943b26ea8975658608568de26d68c7fec9180e5da83a4815a90cf9a3e9227caea1119a890e8dc219f9662500e4a64d8ba1b27ad4b85c73c289f25ad2a4b25dc6e0d6d5378faa0c73edfe70da11b8ea7dbf643915074a749b1fa91b4364f398f1e6658080990d303f838c170f3888f4445a30e1a24b90d7bd237b4a854fe2de3b9ab3fc569b10c99fa4cd918ba693fcf4cf85faa71a4b0c1b47c486c2bd860284042cc7ecc8e21da53f0e800fc58683ea780e4dc3cc07c427d6f46ce723e39428da69775b6301cbc0dbe503d6b74916a7b231f9821af59ff730d125792f0dc07255e9649749b55692a9078e09544bd62aeebee66da6636785ce4b500e58be17c76b61ff14ac9af95b23c06582fba2dc7eb5570dcaca5b7ad270105a2f8910d4129a87e016393b9d2c0d26c371ee89c724b8562805b0d8a92f0db80061d4794db3b768b2d58e4c27702fb8568a13ca8bc073d9196db0710a53433239273ca6975f1d853ed93315b24fe4313fd4930481ccbf8e21186ff04cb99b08b518de0f832d25b086aef612d1d78383826542413a8cfbeb1807dffe3eef10032e18f1d9425107a245ed9b1e589bffbba8ae83b80257cc5bd181a1e750fd1a74ee9f3302e8c5fc4d9b93ac063448b536aff053fd15052cfd43ca59281e401f04d51c020c9be587c03d742a7059c613d5807c21655637af0039fe611931cb87723438292170e05281c3240b3ce93e27e3deed555d1673cdf03f828cdd42adbfc94a10b3807fa5012617429cf4df608d9d28b0df07aa3ee7262f0ec0c7c3844d21990afc9ba8dc75c6ee11f00ca3ae63d0276398a16871013915f5fe96eb4a3ea8d45355f47931239b0ecbccc996641718ae98191eb2eb3a19666a4c8fdc87ebbf6c9aaec72a2a9634b2f5b5c4dde5566ad4b398868bd3e0d85c8f1b43225f2721c0d73bcac10a8f37537e80fe3ab852584d316e9b001ff6ecda35e67f85a41f09fb80f4f12c11f296c75ad4f2af687a9312e0cbcb7eef6bfa597f354237819e929f83de8b1ede46013c6edbc001c7e8aef5033ace2038847a85f2cae1f5aa8da506bcc350eae8f80d79fbb9b1a0b564d96be76cc0c92c517014bac462cbb974f3909531b761d41a23acee2edcda24d1f4ab86fe1e3c5d94a06a486feeca01a2c38001310c3db7199eff00390b1ce7c46b2526aeb7426e175b5723f2d11efafee824b21a73b264748897d5c7e6c93a1d0ec8deebc276104a8c7b51f2244df6fdc053f36bf829a62f9347a67e1abc78f0ff9c921ce8f2e8adf317574380d7f503725ccebcb16e38bcea4b265b3290c2821ef82e8a33e7280b08ca8a34476d5b356875ea2010ee816aa5777cecd9ab609058c3e62989ae8a395af9ebd16cb2c36cff048e4a97e46dea1094ef6ee76802a020a5ec138210dae8457ac98f6dab95232b288a1a6905f612dc91974f33041e8ff42dda18ee1415ffc5c66921c09009275ec7270e98fb0c7588ad48dc277cf9b2b78dc330e235c54d28598353d0767988d13659f6e928337025afb2e6b2815bd71bb22e814e99907e292e4632a088b8ad8a538ea1fd487e3a820d0ae88eaad7e3a828a4a70b4f2e347db9da3f2ea4e48adbe100b32a7a3ba0a70579cfb88e3296c0b16ae107a75435af4d6aa059251d26af2e6b094238d3adf7ddc33b3ab86bcaf6cdcc6ffc0d950614cee7ed857a03189f22e1b7dcd80991e5a44af8d1a5ef20e08149bcece6470958bfb4128f3c3437356610d52463de10d2b91d33b8c0c39af367654d20c50e1cae67e6a569cacbf1b75c78282dc484bcffb2f62bfbe4d831e4ce55fa36a6e70f3fe29754243ed9bdc8e03bae5b43aaf63d862ddf8acc6ac5a885945793b51cc7aa004ccf7ea307949effd2bcd1b1d21f919a345ec3b8b9994398242dc612432909079c9473e72ffa56b589ff01ff4a850a207189232b3070802347d3ab245b4df991d6d4e0bde066963150013ca22b2d17cfbe2fea0092a70fc7d2d8d9f45b8a5c2b74e00f797ac18d1a42bfd834c61d8f704fa4d39748387b5fe84a58dfc20dd78969f6ff9fa8e4a0ced045e1bf78fb7a3894356d106de4acb51e591908d792985026e0ffde7804407fa5bd56dfb5ddd12ee8e023335d6a55cb0244cb87cc76ff85af97a2dccfa947c494e9519bc2d21f3510598336b113c95f93ec420ae40f9b76ee6b37cf7dd1e6409a724cefee56d8740d2a1556c00860780d85ff41e26a654ac247950e37cb0a91dec6810930f0de549ba11b83083b5f430981358f50f2382910d470ed4b3baffe17220af842576e174e7e01c1047d350d1c9607cce709d21b04d6031ccdc580015471a59544570a5e571caef6ca2876ebde1c5a23aa3f3807897a3c12a6cfbf2cef9d99ebde4f96e29cfe38a83fc8cfbd0fb385036aeb43378b4d660740050bba034b422f5308f0fbf3f469157ce805a2aa51e2797ac38172bb8615682aea2ef65389c2c97e4a67dcd3746d33b8e6a41b185229b8fe630568f6f4528a6fec944cb8d13b5b288ae58dff79e4b96bbbf25520a60d60d85181976b24fbda2f8310a8b972e30417ea8977d8b645a56505dde174300812d87cc8daf3f7daf3847e72f7280398b8c64722efac5201d0576ba92dd0cf09c9723caa93a2f49c987d2361f8a80fde526ce87bd3077758e515c5bdaad68675ace356c76801fc21b0d3c3e34879ad07c8406a1b86894a153200466842d1205f5d64230838fc316d3811198a4e6183330bedb5e4b99dacd0e1b8df90118bd9d3cb349558b8e33bfe90a706ddb40b2dfeaed5af72f2b3e6280038ab60492f244e9ebea771c397527383b1bc8b2a65ce7cefd38321c62fc5f74b1b193ce6fb60e8fc4c2fadabaad64160820949eae1da1a5c5d6d9765ea2964e119b38d2bfefe1d63342dce325d0940c0c6efa098186f14976a53406aa8496058a3436ad5b7f16d3c13589c6dacbf9d9417de935d4c2cf89861fe33a815a0f999ec0fe2268db3cf4adbddbe9fd9ab1d8d341cc902b8656c7126c854601896f19ea500c10ca831f468be0b6a6c82fa0fd6e2805139f5ee96987989020fef2fe4b7f86c9d3a98b31a3ef39c5c98c3955847f0b3c0fb6e30a4bda0ac69e1cb80391d5e7c57a782ab4ba7915b3a9b023149cedf5487b828b7a30b85730479eda9c39874a71fbe68a91c5a4e295cc5fe67af6a958a183a36271547770bb944960e4edd67fb647ce66a890b7c863cf0a7d77a0ba4134d0da969d5c4c37df9c45e570bdbfa593d7e3f8307ad87c25572a0a6bbed887ea96d8286a72f0acc765bc132612bccb429c1072cb899044cfe15c4e62299c0f411f8b440d4db8d7ff43bb58c6ad9a6de40d1718df9f9d3ccc1dec794e56a6e61c57de09549ccaaaef773e9e614c2aad56d343abeccf65514971fb6cc2acedf978950620211b45f2370469b17f2150c89036fb4129fb40d3b1b840e2e0a30bfa91d99f845555307fec55baf1b3c44cffe80a2d60d1dd57bd6c7267e1e5b8e2739f661188568ff0a1bff77d720bf08a25473d4849a168b5e0b008997025b4c4bbff780ec8168e6a0ab3a19a446f97f394e7e4df6afb99ba1752ca0e4d33008428e0f7e2643d97a58459e7c606fcc5fa3a6e51b1c238d18ee3754f62daf8858f7f76b36b7e3eb9b669b7aaba9d0ffd930fdd2704084865ee5408c19d4c1e658e682de44ab3828d0ab9768aee179480a0881854bd3e1da587d85fc606773759fc91a99cc7b63ea830aba2a0efd3ed369c22951f659434869db1124f67057e5613e769a795fa7f3e0b02dd7f4ac957ff6d6a27ce575ff6e46a3e5e4315d34839cd4bf86e7c55f318d79112f8da6c914ba668a9c19678ca857fc8fc69314efb0d264b2117b27ab8b9c178a6e9175b41a9785439506e8659fe25de7a8ae8e7d21aeac305b09193a25aae851e84a1c2fb24b7f16ac8872fee55c55b3d817a9f719bc425c600ccf005e10e3f34707fa78605138e96802272ac13e6d46d7cc68a459beb48ae9e7716a087a06364e0eae01173c350045fd55b00c457e8d250f69964124836603cdd71c9b593e3002df380ddb5b89f7247474f79463ed97c4dd2d6e07da94d410588df1d5c417bdd9c183698386e7980b3fd57bb809adfda992d12a45c510011f66c8ae5d7c14384ed48c11cd617b2a9e5468e87d13c573661e7649ec661e9e88df475ddbea40b2d6ae159a620cac774faec9a3b6c4b42d434297e5566fccd628383100a038db2cfbe9ba781941bcd6c6a18af010b75a9a4ed7cfa886bc3f2e78927594108d741ef9967947b8987c08039a6c58bd8beebcb4bc0421adfd4b7fbfe152a7fd30c21fbfa4fb2c8bbfdc9b57ad0d707f20051388c506202ff194d0dd1fa8ac1942fe30f2cde0ba3fbb044f4454a488929e7c8e5e9551c968d450041da99f0e8d313a819587c7fa20d84c87d04fb686ee568992254646d802d2eca6bdf1864cb7a3781a76c519d0f80df9e51983027449650569b6a45a7d5b99350685c495eea294351139565cc77790f587a50b39c5d05e2d3c6ac7861a77ae977a0f672c5ec33f93bffcb9b5687d58b0d9804fa6469cf6d72b1ed1e4e9e2f298c362235c8258f5951245dc33c0c965a150415492c4a30bd39e9ed2899730dec8c06fb87c93cd147c6e68e2d7b63a02b2fd73b6af25d060f26041f4632495ebcd75c79fe5533acc589b36ad4440fde354ef3a34e2cca6eec877da1a4c8276d000d4a289416e32b1b226f8eecc7553e3cf61196b0b2be571120d735cca077d89cbbca8774e6b880af2dc291bbebdf4ecd5e2da0884a39efc3cbb576fa5001a43a79429aad8108dc4a2245caa9492ceb0fb3988aa8ff263806e260f04e632a83d88411c7bf9b3a26e9a1e11b460f3dc4e026e8ec597c531fbb6169c6ab0138ddc019dde6e49881d72d0fde24236cb2859fd20b4f992933e5c3522c6871279b7930a4dfe24bc3a0892e187a12bb78b834787b37269da5017db694b8a3a5674ba403a778bcdcf9c96ad8cafdb6ef7209cca7f820901bc846b882ec242dab0eb67c7c7bbce31a63c61eaec1df9417c0c59978d9175917e06de83ab7bb6c361b572b1d7f2cb6a5a67f77172c997760e200bc3758b786b530d6ebfbb9ef75809655166d7af5e9bf3f8991fae6ac1b26ab010f77ae5ade8537ba502c9de7a91f49ed05b55c8e78dc782da26abeec6ea26157752a01713df52afb53ad6c7db772e16263afb3b47cf81349d13ecba359e194a949269a6a942d4f4f89c6a2730b75723490cb922f70cbc244972571e6bf8138742959a899c783129690beba1cb9c88f7849bab1cd28a51af3edb367f5853f2a22c482ce0deb832631e65571c3dae19ebc1459eb5a36a2dc31bd8221199214bab7dc4e44851a2f47626b0d50d932d03707ada68a987d350c89ca1448dc5ea567243be41495f86b72cc5416aff1efb04a74f8586c8dd4e4d7a2cac3fc0a5e6688e02609c9e75685e904564cfcb7eafd9768ed9daaed4c5620a2a5120a11461f577a2b2234fe071d89197bc582aa5bfafd3c9bfedff1fad6dcf163415d2216bd228463ce8311164f75818b86b94ab6ec743d55783d2f1ed6d3d9bd20ca54351a07a2c521d6c933198436d6d9fbb591a7cbd1a8907d34bd726e6b7a7b9f1262f331e28b8a1ad4ceb42a86db688d39d3154235b536e4d741731b08fea25dde855ca58225103645044b84c764d65976eee153db09a2046500c79e05e3abe777264687392a66620cf7fa8a21c772cc8b73dc1e9b4b1236ede91b1be09b507b163cf83daccdacbbbe026d8e710dd913fc64373a12f173274644442e4e3abf7a31d01593a944d8d3de16f37071805e92deee012c04eba3e145aa7ed57da9834f0a1487bcfcb45a7ce66826c1c2b74b9ae8e860132041401197a57db4435ce75d2bdd0b1be8266fb54db81029a477ad2808e7c68a3987ece056b9df114f253a878133c3d428b051c69718a78cdea1ad795fac1383f723083194d043e02a2f6e820d6eac0fa1a6bc4f1c7cc4b5a6a66bfdb73e91a12c956ce299a4f525aca0aae24e8e57240719fab9a54c99c857a9f6229f995930786ba289b14987186d19aeec461bba7a2ee5858cfdf11f7b471e9e0e211b2827cae59ce1d9f4c89c3232cfd1a0585435c4e55de8986cd3ea72aa1f91ff21efe992b347240c46162f175fad4ed5ecf113c81bbe057a80ad97ffb7eb471b5d9631bef77abd68f37aa88fcd2d853d475e7e528d9d70e9a9e4852060d6331301cd435263582e46acb026f2978193c27294249a9be2234f9c35b4189ba92b0cc18d07eab91beb3eaac43b8b3f235badea945d1f5b6e71077daaff0eada82fa4a969b540d940f7e4148d7bf5a29a56ea3c09424a84c47b781c532fa21329fbeef5619273f20e2c2eb0c77e6e00c0dd73447f91abd90678d5641b2ef18353d2d903ae9ce9d9071cb62de546941b05ab492b7ef0a83911f88679813c34267449d0786f6d9657947897d2c2fded1f88653b8fd8db4d190c97c2e872948d6cbf7422a96da979a98b71b58d91547f86bb4900b0606ff125ec2a97831febb6eb60b17194cdfe982e188bbe004b99e417ce41cc3a238565ccd55451627b1143e74a0d8583c058e286fc67491423151125b931392b6740ae270b5da09f204d6fa4783ea3633079aeb16381ac00ce1e3ad18fc06e7eac0e40f0c6fd7abc70367b963fab122f32dccbb1b33e55cdc82b01d4423a46afd4191eb2ecb6e26df3eda8aaab8664bc7fee68fdc102d421955dd37bb600c53f61b2c739eece333252353b3829710711a94e4847c8284dc4b5190860389d16799d4251c8f2531ae97098e145aecf644969cb33d39cb9d87293704e22c75660e4a42231752cb1ea87bae94a196da1975ea4f24ad7531ce06f6c03119c90febd115b4c75d9d38f3c0a75a1393517fd697f39bbfa99f4cd98436ab484c038e9ad8f26ade368c8c74c92cee9b35885a9a6eb484c791eb7d013cc8a76a46eb5a48fdaf7d819fea24b6198c7ff68f342c2d94f0331fa644bd47c65a31a3731e2a5945675c6e6ebd452c1ead955a617c21c516aa6b2579f7549ff482e3458f1d116dfd7640454a662718bdb993794e7f661b26c0d83778862811386ec2df9c17fcaeb9fed067e1f32266bdea10f194d04d5c6f2ac137e3027719618b48bb71a1569d293a5a49c5b474f0024094ace998a77e2726dd07111be48e3d61e0d2fd5089b3170a5e054116bdd8f2cd3f6bde950ca7fbe8d9a7e6037a4a09042cddcfbf03e819387d5ce5a334f53f813c3449248946883194647f5a86e1ca33376a0543c236266999a67d535ab0049d74cfb3bb07dcee1230e48f663aa2af1a19ce9d7d7be27e8df2484df76ad1d054ab32d107706f9cbd369c706785bdd11542c2cb99b09ac17de6eed37f02a113d933b4fa768e1b7667474949ef682b2f86815245eea97600a372cdfebfe41b63bde00f999ae4984c1c1a9f9ef1466f79ca5aec2e3498bba6b3b44de7d0e6c062b129b5e8d1935e32b5f6ee8c5551d09be17ad49b7b76470c67a09f577708028cdf756129c8231e8801bf89631acc9a221915b11c788b983b2da94c245254f43e14284c20a8700f6cd5c6cf8d52f747f9c35921fbcbd970a97d3eb2ba370db10665ca03fdde8940c3b892002db6d689db239bc12ebb83eb51efcfaa88eca79d13b6f378ca477194c527a254303089d8cbf11cfade79556f32f440d13c496f1407899bb1446ad7e1c5be9040cf4999ce1171f4a9b80d201fae84dcaccde1fd93dfe7bbb60025d672402b9da6473da3e76a0f2e5f4a57de53dc0f241fd13cb56a34dedc05773c2becce0e206f1678c3f24be5fa65cd1c60f4e84f3998b1d8ca4e63f179c8cc6ee5589eefa4760718aaec117c16596792325683f2f44190b7725d1b9766572c6de9d26e7f0360f83e508d27e86bf7b044a16f2b32d508be3d41ef46cf3139cffff786fba2a03837ed2983487833b812704001030753de281da8f86a2067930806455ff63fffe5cc0163bd5ae911da87dbddb542f753f3c3393276ca14b314ac3784ea29f62984801711e2c7edf82f5e1355d99f32f9770609159a952f5ab69bce29da81a9ffd038a02ea136bed9595","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"50ad0dee8ce6b9dc1645f409ec5d5785"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
