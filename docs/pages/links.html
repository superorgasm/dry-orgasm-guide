<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="robots" content="noindex, nofollow" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid rgba(255, 255, 255, 0.08);
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #12121f;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
                border-radius: 8px;
                border: 1px solid rgba(255, 215, 0, 0.15);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box;
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px;
                width: 100%;
                color: rgba(255, 255, 255, 0.85);
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: rgba(255, 255, 255, 0.05);
                width: 100%;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
                filter: invert(1);
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #ffd700;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #0a0a12;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 4px;
                letter-spacing: 0.05em;
                transition: filter 0.2s;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #ffd700;
                filter: brightness(110%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0a0a12;
                font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
                color: #fff;
            }

            .staticrypt-instructions p:not(.staticrypt-title) {
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.9em;
            }

            .staticrypt-cover-image {
                margin-bottom: 1.2em;
            }

            .staticrypt-cover-image img {
                max-width: 180px;
                width: 100%;
                height: auto;
                border-radius: 6px;
                box-shadow: 0 4px 15px rgba(255, 215, 0, 0.1);
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.85em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
                accent-color: #ffd700;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #0a0a12;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid rgba(255, 215, 0, 0.3);
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }

            @media (max-width: 600px) {
                .staticrypt-page {
                    width: 100%;
                    padding: 8% 1rem 0;
                }
                .staticrypt-form {
                    padding: 30px;
                }
                .staticrypt-cover-image img {
                    max-width: 140px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-cover-image">
                        <img src="../cover-image.jpg" alt="Cover" />
                    </div>

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p>ガイド購入者向けページです。パスワードを入力してください。</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="パスワード"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            ログイン状態を保持（30日間）
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="認証" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "パスワードが違います",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b0b2bb4d42fe855fd9597d7fc70fe2e52e9da761eb7314905a732a51819352e1795f42f20480cc920846c3c7f8139835fbf89dbdb449e757e0f4fd8d120a8337ac4ce37caa55c193f8f4a1de841292f0fc3b660fb293137c602a5472c0b9dc052afa34f0105e7588107b9e8314069846add5192e97068c3f609e9ff72b377c204d3500ebc7f5d79003e891a4a4f03eed25fd4d7c28056089b8e5b9b134dba8a65e23bd03f16afccc2e1b26f6256a01987bfb283cdf4bc773571e4b21fc2cddf72995bac58c1e8eba865a74df3a08809b2b75ccb2b4ec4e60c40332f272b020af3c7252dc6fa7a5400339a1827e8468f8441b298fd9995c8b3975d23cb104aa2ae971df98f30bdef3c1f7ee29036be4ebe97cc4b2f2b35a13db97b53db51d5eda9efe3c377ae29c6577871be75daf7b3040485557a221e3b7a715cef45f8660d5da9c8f68ea796a857d9187f4fde556dd23250b6473efd0e4b042e6332490cce928e00bcb03c547d02dbea3e4fe7e6630137c9c5985259b4738aacbf2d34e7c2e35db878270642cc669a7dbe7f74c9b9326364e5d9be7f09d8a662253d8d379c584ba1af0434fde67b0a40ba9761653e540ffcc97a27dbc58de93667b7a9218c4a0fdd3504727827022a0d48563769d691fcc1452749aa84e3d736162e791f0d0ce748f9ff014f7c7e3b6e9112a10caa720f9f659224c287d3940269d63bed2c149ff6c2030c6238cb571fffe02563f3e05f3bdc749b530cc7fbf209985b5b64d09bad47d77d77afbc10ae6ab0c45d80ab01f7c3ff87420f90054f3393074456abad860875ca2afc59fc6a712a08b5e54322ed35264da5aebeffe97ab0bd0b97dc1a20e20741f044fc6cf5674da77277e86759fbf3371fc0efdb00c36c3d83569094727ac09a3904e44a8fc6fb937465458eb70ceb17fabcee7a0a2636b3ff5788261a260ba38e6354a3b7c560de96394ebe2251759b3087dd1263db7e7fcd3033c69132062c8b022670e8a4d280c608c70471ed525b5bfb28b1f2cf54b4641d3a3b7e85279fb72fa18b4191bfba3eace6871ffb6674bcb6539653d5a0edfa09bb13f0044e4c9c58fdfd7e34c13759ab17a511fe5f1a04f54875fdd3d9368019cd647cdfe1a9f22832194addbe2422a695bcdce9574313bec92224fe635e46401b254035fc681e8d605081bba61a5aaf2a191d0ac828fd4ea9ced00b66ac1843f997d34843b2c103d31f2735512d40f759e784732129e08248a08d43e50da99bbf800fae74e202f525ade7a712ef8eb5f21b9a117d181df881c63fd1efd2d38ef31b7d3660378c29c2de3cd4a80f60f3be4f89932d5ea745de51bfbae9940611c80300f5b1d8e3e7b1b2434b55eaecf13dc20cd74986b6042778b91f45ed3c96fde6838e43f861edd645f59bbc976fbebae1503057a450772117ed29a7e419da86da2de2e44134f9a6bccbecfcf545789b5c3890e15f109d39fc05ccb12981978686ec024c84f6d23eb90533ff5fb2d194eaf838e68bd7af14171e7074fad1b4243849b3b8f0817990d72db067f2dae5fdb3a056fddfa63d7d8f6cd5c2ab5930445437f76a631ccdea39190d8025ed180219de417d8d757df206137c0afb1c3a9be34e745a8225fd4c198f3770e7f2e64ace30a25656940a4fa6cf05b51eed1ca59a81a6ddc5f89a977a1340d26080449a2737495bb45c687ff00885c5c52a0dcce08c0022021f5526e2b54c09ef9fb735a1b799fd9b441684a4d3a0a319f6bf73088509e08a6a38354308506f4b31d3c1a5b36d01025638799637891585f307e18c6e63cb352336cc18133e41a1dcf57972558098b5114e13323b071269a4bee4044ac8d5e9b557fecfa199b76fbc11edc9b0d46da4a8f4f6668825c8aa90ee5f3ec5a3cf922fe444b16c6153cec434f9d6deb5801b705b5cf63bd4867a326b557fb23784a969b22448ed174a735b9646ef000e5c3cff51b58e1e02ec5d4343d84c76ab68d4fbb6d6bee75ead5dc20e30b45b8fc1404b1bd336c8b7afacd969d776ca0719e2383d82dfb8a83ca294eca830ad3f2c5d75faa6997a0fea299b5e71613034a0bbec7b348b232f9f4d52b9d75255802a7786bc42596d30b2306a8f7b865b21877fd0ab4f18734424bae7f9fabe611834d6a97a49f257301e48448a8afe520e2f09b94f5e62b9f48d9cc65dc0860d5e29cc101faf8a211ee2de3e636c73f05ee3f1ce77e45241327d509b32345eb81225dc382527f10dc201cd9cb95f79956e023e952ebc2ed804e66723393ce2eb46e10163994ac685c7e47b1feb66a059a6f6a451293b7cba40e93159b3ce360da41fc09380cb942d8feda0ad258c4b609f219fb012332fead93dceec37974f6d282e13b4f153e08a67d5d1b1740a45cee6a0246bc8f9bc450ea10cce905cc929dc7b9adfe9a689fd1f1cc24c107986d218355de175bd91c350e48cb1fbdcee122c089b6675b6c67b94898aac7345df03aced1f7d6572c7589d8e01a3b202ac5450fe96cd149d25e0f3b084d3ec60735d052451a54f00720550b1ed2f5718cd2192f80ec9a6bfd8e77e3117774d17355ae87d4fd64cb2430a0c49da9fe7086e63e807d51b8e0b72914a9823408096e76fd174783c711e443fb5f6cd55cc131ca54efb2d3ac6c4fbd66e80a3152c3847cf1c7b7741f59916755542f781564721134e0f1ae49e0dd11d9dd04fefdc3f10ca4997bdad89b802ef410273dfa6691d7fc0ba21daf40069da38b64da940f88813d5fdb366070fd2cd2494061e7e5a060d056bde26fa0c29e147a5274a9f3bab8f360b40f588b64790cd5601c605770606064c009af168e67df9e9b5b1cba2dd801127df79bd96e27869bad159b09a9cfea43f7290b67dabc08e05f31320d9515768bbe53bdbef80213a8938c306a976f890658fddac2f6e5efc17aabdad7ff2ae3be2326076a52badbf92b54f8fa82b22f5ef7564e82aee94027cbfbe58f397649d3564e8df97bc0dc2930e39bec1ed2f35817ca7d6736ab9c4f87e04089fc6f21acf73a0ad4b2c01485987f999eb86e02a7f2c701bc72deb7501ab4a497b4f8ed8403fd3a1b5275ebab2b94c0a684842ce17ddaf6c2a1c01e560c7f239f741a1a83893c51935c55e2d196c71f4f1010a6d3ef48404487926ca0aa6452f2191007d23e484c2574f166b0a249ddfb8306acbea6c5e8050450aad36c02deab04fabe74b1c1945e0fc267ab79b69fffa78cb779389a54e2a0e271d696ed197b8cc99b12cdb50dca9876eac9652670c79b581a4f2032035709e968649b140d41ef4b0bcd70710b9efd02136517d795571175d1587048e78ef89da5f6601a6f9c122cab2fd032b7342d991c1b0d5b11670af729bfd141ce1814ee772b5ce4263c1489e2ac322dd25dfc3605875407e40e0cfd3e218c6c27aa2981d3d463115db0f4b561d794b4847f46438233f14cfac8c589d8936a9c444277088d67449f39df9583579bfa39bf7ce58f30c8f41bce640e189545fcf20047af83fb6041c0a61d87c15001232ab0895ce1d4113c9d9fa7dd6a3c3883a3ea8b9d34c1897b9aadf6c8df5c748a23c8ae3ffae780780cc803d764824f1ed51b1443ec39e886dac0b210657c7ca45fe6f57774c3d4a75a17a16020cef0d9d78f888f125fedc0527ee791921d5725a2655cbba691ec673b67f03cf3f81c379b999e029fc2a3f17a0020999e6ae28ffaa3fda217f7fdeae2803fa6b7c601375fa521bd5d0343d40d94d453e6f99c2a73fd032ed2fe0a9c38c45e61217ae1b04e8bb052330dc4e11c7f46d3b72a4a202b49d1d1cfc50b3f6e9a2d10f6d2aad194baf4241807c1d446dc1d2bd904d4290c19586aaccf4a522ff2bee80c1efda36200682601d31649bd60d7e9d2e92a0f686f4c5a29c717bbc0909038bf98be11c69b3023675fc1c860335f1b18d5bb07a0174e704e4dd64a38dbc0df1bef314015cb954c9f3f882f80fe352b21e8067698199549d146000cc29c76eac324c42d2e4d9420aa0631f0e4b1f007559deab617393153034b625dba9bc4ed3fb5a95064ec98931f6e699918952782ed596d919e4cc90cfc532862446a122e86e6db15b3ed39254190e8f1236ff01dca18d058d95a7fe4c345d553a4dde9950f11f0c3a2a8d324fbc3a01ea710b273548c5194b7c0d8aa65084ccc5920f053aea832ed40bc668180645167ddcfcdac09eb88247ed2a671afe5ddb1ccc4b36a7da700dfae8defe96212bfe52b9c4f357341040f630e1e894e39780ec97bcd60c78e9de6438ba8fef40971a783576c439fd562c0305b1586a5b1b412cc3788f2bccfdf018539a7e1fb41a64058e691f7d195439604c0b781351a110b42ad0df57fba80c563a4df7da94e91d93f172dfdf068ad0e216285093df07cce3630313d558a1cd479c044f44e4d4fdb1de32945830968372f59613f46a32fe32a836565e9b36770e56795210866cb276662f8fa9c816d3896ef52abb472ab20f621795a2358d5abce0c554ac8245b8ddf50fddcb2124941c410f80f36094d6ef0d509f8b8a7819eeb2313125813adbba572a962a934b9901f2c2947accfddcd5525acf90acdb4a49595a125e82c6b5a4aab2399ab5d74e88dc068f9b77a4278c2bcf80bab78e40de2fdfa58f250598c39b2ea45f35e89eda6cb8b09370a4abdedbe6a4457b38f0c8a44d088e38d46d2968c3a0fdb50ea20db999f6406013f34eaa2501e6a71066511fa540b47f1f8ccd0315a7b4fc19ec0664f260deb9fb716441e3c806d7763079c333e668c496f45d409cf9dbd858a80676af6ec643e9b07b6878e7a2e7a3aeacefdde780863e5c04b2be5ca6999849865bf3d46bd2da64725146f38139b9f7236159a24a71eef0c7e57e21f324dad75bcb05aa38507ab648b3208e1313819092dedc77df63f6b119aaae3823117e6172ce5c542aec094d255058a178ab7746d342e14f46f9bfe9b7b18719d4ce7f4f472043b0da8a0a6e0098ab2b04612eea0af4b594d50e260a863c35992e6c3293b60840430437d469f2b1530601fbcbe4ae6136b44a75f795a8be6e50ce6ce31967d7bdc5a6c96c811ad95638d288441d8683a25f696618700571f325f66f45b7f2a284200b594cc48aac4b52d9916179810fb290474d9a8a6c64d96ac05a2c4ecbbfdbeac5430776b8f674dbba6f5e0b6cab32a7a1cc664417d1ca92987b448cbbbad8305cddcd352749619c9dd37605ee821c9fc78ce033ab2a684fc636c43448feab3fad8fcc686b24d9ebb75b2b052bd5756596d3cd22f2121f72a90222a7e932ce82ff147772b2f7c6b1347f51a52d3b22cc1ba31477e377713fea7495871c67f58b2abe21d0e2a02601c61eb1a7fadbce0b22b55f7af86bc3c30177dc36430bf61bceb4eaca79b7adfd7e78d0a6da5b00d16c8cf7d7ef42658255ac08238bc048b6fb421ee8d67f296831d9953ae686545ecdb21e3b10f5227d9f2d6cbb374be46878049defefcd33c78de40b91101b50b783f198e27b203e6804947a756c2bb581349711607f07af98fbfcc0fd3cf8d1081a6cba50092661d460e2cb218532f4dea68ace1c00916a0081efa120c3b98ef774a3a1ad6ad887d4fb79c617e76434693f1133902b0135f8575b867941945f249b5c4f8cd942ceda7f01284dfd7954abf18cc2043fa10d80f16a6babea08f8b61b7803a115b643d973726c1cf8a5ff7ae764dab67eaffbcefed80c54311ecd4aa7be386a389a7576a59422af539559c6ddcea64455bd194a584a2826f22a26543d77e810ecc9655ccfa517bb691b8768285f3f7dce352f492934f2da9420cb944bd14223c61c3ad59b9f88e4f9f781873946402473337726fccebaa89ed825978844b7d810b1dc9ad10605dbe044c7f178556b9c886b54428cdc10729749fbd8b6d6ac67b9dc44644622f5967c222a1154763c02913e330aced1b5c81f9a53f1988cad54393506bc21c80e004a8d55763d42f56196d4fac0ecef3ecd2e91efcaa485294eca85735616560140572644e87a2b69ea824f054d3c384559aea4f33844594aeb312a09f054540c94504f1da59dcc3a4708f6c6d51fbcb4a32c7ce4ab6ca3da37e7bbabb51e4cf49e5ff4684c3a74c61a4a96d37546871a828239ec5edf531e88b2c628f75c64a916f7dfc913a9d6bb048bd4507c1f659ba1b9c4e1d2c55a2ae5416e84eefbd04a8f93a83095eb7860e3de6d3a0ec0fad2b6983cb923603a0cf89e4f3e22574ce906b7e6b57eb788b5abf58f6ff7f46c63200054e98113314d13ff35ca1ea39e440c8c9c16f031a13363db8043586084c5a86437d15ad735c55dcf81e99984b1e07847b528c86e61d87d532755d148a72f42247b71364037d169a0ff55563f40b87836083a48ee1293ad80c749998605151726fe490558255710cb8300a9695e6fd94d0be2c5d3ad872a219dc7c7439d4b0c2ac39221f182366739a191237624f9beade560a5fd17a097aa2e3cfb9ec86f51bbc8b9f16fe90097b1e33e0c03d90b964d878ee9a22543eaa3b082d2386d2a6c4b4be67d9e6d283d07a37a7ca058a399c40f97b0ab769cdf160f3b93264a994e8f71958ab76f42550166b74a6161e10efff12117e49192636728df366b1fe4ed4956d1cb9e45ea3ecba6a585ac3ead551949e2083fb3b9868f63f03b28a646ae9e6a27f4e85fa7ceea52d643e96f100dc4146ee0dad5898277268749a05a2b6cdfa9709a3dbaaecaef1a3a28ae29b9f2a0e2cc3a4a62522880ff3746c9e9ab44899ab8b54a2898428f2600f01fe8de62c1e9e9a1f1a8aacb8e00b108a570336eda25f605f1811ff00e9a81b7a2c135bd32fbd78b25db8b2eb6412ab7c7f6409f26e88b9a33bee85bb9c630c40c630633d928f85c11cc6b1e3648e7d3a6f33698e1e41433da853bcc6756cb18d07763dba1b8ece2102f0fba89138ef85f7736012f93be07ecb567eca48c583425435d46e93d9549ee3e7823b9ee5907797d8bebc63c907418b31ec0ee0fd480fbb76bcd4f9b143a2fe63cf3f4ac070f1bf7f0bb0242bcabfd1bcfa4e17bdca69db3bc8c5d7944331e7d9d291c97c103cc98e8ce75cd808a9c536f0f4a10c7b73f9e829432799cad471cb54cc65409292fe9a75de054c61b250ed16313bb630afbf32b166013b051aaeac56abb26e2599677b33f869e9e3bf9df78ee00df7e34ebb8580ec0ce2afab71fb97f9a5d11c3bbdbd4befe7c2803221f77af1843bd9398e64cb98bc80b8665e76a654a2c9d68c5180cc2fad3380ea07f8f63ff8a93c873b821b69da2cba870653bdd3bae7677e3b04a8a19283c223caaed7b5ea8eb1c3317d150ccb8b5209047fde73e33cc1feb811966c2aee05e41fce0dcca99378d4f69789ecfaec31c7d4d9e109cf07225d3ffa7b7f8b158dd14248f9e9d03752e762bf312fb70d35593301aa517a620eb37a4c6e1ef592c019846942e08750ab564d239418e28c4115b505b65395503e0d3b82e4cb10e82eb912958ed392864e825beecdbd49c1b9bc578f91690946dcf9d24842a70c3142389c8bcd9c880a8e1c41d347ef1a99a3c41a1073457e92bceaf25188d349f3c45faec17a8a551859eff421d773be9adab091f09a19e950386f0bf4cafb1fe28188143d87e479a6074b6a0509d5e79bd70015e617045dd9829fd4a193fc94aa5b121e7cf0e3a7c45647c9147a8243645a41e925a35ec7ba1fee6937b240ede4495d6a910c5b5d1487c09cb03039d06db9582ccf306a197794a96e0e49a1e225d740b741d5cac3d785df55643140ae8b92629fdab1e5e096771b05230a80b2c89116ed683db5375300cae0e6726aa5918d111724347bf4c7ef5a1b285a578518473828e9fa769744046584c231ee8758594481c3cbe3f085c6d67d504253861820839ed94278e4c7e8b59f29ebd6900b665dfc3df346f2303f925974b9e2517c15a92e1f6ef46abe60fab844917e1cd673eb287c07712b8aaf7adcf968bdefa9ada788b017336632750aec9da7cf6a1ee95283166f949f0809c711e6891566159200428956d40d03275e345caf5f630005ea44baaad95cb7f595abb057d4064e6a5e2edd390e3ae037adb40f60389745c3946e95b0001b281586359b25afc2776c8b138989b8433b0eaf29aa9f0e23929f1ee63493a97fbde2a252158782779ecc79d3e87e36010fee97f6dbe5413af33b930375c4acc87152113e82ba3d07cdc0ffc76d6d7ba3b7578019607837c07991c5487d7839bb5bd63de669003616a3fa33951adc03600cd7db4ca54cc98b19c4139407a3f392158aaa471a77af255a4c817676a76e6211b0ef2f71acdeddebed3d5fac22a6ffc23c94a1def0b98cd96d75f3ce6881787d25","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"50ad0dee8ce6b9dc1645f409ec5d5785"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
