<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="robots" content="noindex, nofollow" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid rgba(255, 255, 255, 0.08);
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
                position: relative;
                z-index: 1;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: rgba(18, 18, 31, 0.92);
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 40px rgba(0, 0, 0, 0.6), 0 0 80px rgba(255, 215, 0, 0.03);
                border-radius: 8px;
                border: 1px solid rgba(255, 215, 0, 0.15);
                border-top: 3px solid #ffd700;
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box;
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px;
                width: 100%;
                color: rgba(255, 255, 255, 0.85);
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: rgba(255, 255, 255, 0.05);
                width: 100%;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                margin: 0 0 15px;
                box-sizing: border-box;
                transition: border-color 0.2s;
            }

            .staticrypt-password-container:focus-within {
                border-color: rgba(255, 215, 0, 0.4);
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
                filter: invert(1);
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #ffd700;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #0a0a12;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 4px;
                letter-spacing: 0.05em;
                transition: filter 0.2s, box-shadow 0.2s;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #ffd700;
                filter: brightness(110%);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.25);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0a0a12;
                font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                position: relative;
                overflow: hidden;
            }

            .staticrypt-bg {
                position: fixed;
                top: -30px;
                left: -30px;
                width: calc(100% + 60px);
                height: calc(100% + 60px);
                background-image: url('https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg');
                background-size: cover;
                background-position: center top;
                background-repeat: no-repeat;
                filter: blur(16px) brightness(0.2);
                z-index: 0;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
                color: #fff;
            }

            .staticrypt-site-title {
                font-size: 0.75em;
                color: #ffd700;
                margin-top: 0.3em;
                letter-spacing: 0.02em;
            }

            .staticrypt-instructions p:not(.staticrypt-title):not(.staticrypt-site-title) {
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.9em;
            }

            .staticrypt-cover-image {
                margin-bottom: 1.2em;
            }

            .staticrypt-cover-image img {
                max-width: 180px;
                width: 100%;
                height: auto;
                border-radius: 6px;
                box-shadow: 0 4px 20px rgba(255, 215, 0, 0.15);
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.85em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
                accent-color: #ffd700;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #0a0a12;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid rgba(255, 215, 0, 0.3);
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }

            @media (max-width: 600px) {
                .staticrypt-page {
                    width: 100%;
                    padding: 8% 1rem 0;
                }
                .staticrypt-form {
                    padding: 30px;
                }
                .staticrypt-cover-image img {
                    max-width: 140px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-bg"></div>
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-cover-image">
                        <img src="https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg" alt="Cover" />
                    </div>

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p class="staticrypt-site-title">ドライオーガズム6ヶ月完全開発ガイド</p>
                        <p>ガイド購入者向けページです。パスワードを入力してください。</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="パスワード"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            ログイン状態を保持（30日間）
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="認証" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "パスワードが違います",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25e14842d3733cd3bada196c5af6ebb7e25d29f9f6a89ca7a006ce60915db228d6197aa2b2139bacc32177a7880eac98da439f317a8c78814b06019b9055e016c4a2aeaec2ad2a363741865ad02760b44e3fdaf68e9990cde5905900a60e55ddd33de80240153d2cb9930c5324a7c0863170ea689cadb6df4f2321b991e294382e0590e5a6f881b7380cc0c6983bb7a52a80da70ac2e5d5d5ff34bd3a48b5d2af4932397ae25425cea9f54927ee003e389ff7c34499496128eaeff7aed14f3786d2d6ade895c2655ef213a7b0c84bb1de5477e28304c1793cefb6c96c6215324d1b2fcb4c0730ddecba4957cf6c499af6246d963d897b8d1b0b602d17a57e71dbe5ecaeb97e8921ee787e20cac426cd0a11e3372b79e25b3ca80a0bcb083018e5f25569766af99f5fbe8b1c4ec4d55257bc651765f464a3859d6806b9cabd75817380d00eda05ed61fcd2516d46804de368e1d315d74e1407fcc39a27c40707a913129b4d515851a96eb7adeea1678c77c830deefc6959ccb446a010d7d09e3c92689d8f8370a16942c84d3426caea5de9482e1610ddd38545c687daefdbcdf43723c22a9034a060a8c212ca33221234f515609645807b107bd45c6cef6e57bea9b01d1045b827d9d7b4614c93af7012abee65e3d85bf2960aab7f0889e8c8a2796d5e5980b38cd663d8bfe3e12f663b2c363410896cd49ca501082b86d0bda8bddfe3a0d11b9a625554aff93e1cf4d86fb3519c4f1e076ba732f8c0a98fdebe7da1ede9db520db9236e9614db62be862fd712434da67ddb691d9251d5a735427f1a725e402a5f7cf1a30b29dd378b2023f052db4b98b1b56b8a81f9ca29622304c5f9b22812362e88c912e2f36ccacd280402e4143706f95b93840f613e484844b6b5148080f5269d62c83a5c1b565ef5a7131d209010a07b90c55c998d7c296079b40455b07c367d58da497a8cf6b974debde64fadda7debd7a24234240564ae10e6602cfdd2ba35ff06d2dbe0464d27b3cc319805ce59b95ceab514c86f544be6c7c53bcfa575cc3384c0bd32d649eae893d3843bc3964b529fe0a00244d25f98863f38cc6da03825b859e7d58911ce1fa2434c7021b1c479f905a5bcc70f45d5c5a12568ff8889a7f5d517483a542ca51b857ec999c93d04de0d92ebf28d459ca77484dc8d72c15e02973cc97eec6ce310f198f31ff342166bcc0b354cf55e6ba8807185a8ca268098c4cc3dad9abbbd1b17a86679c17915fa361b9e05dc272183cde8770930368d9a797be315dff160819711b3b5d9ea502e97874524ac2de8738d6bcc2f325a303f216794f12217d92f8eb76199a97653943082d197eee7b19b33fbbda7f9c770c7a3b6305a8f422d0468aa6e2324159124cbb98885b2c48ade480683d7a9b00c89c340c11de502d3ec49d6aa9f3aedce303862605e529afe7b96b43134a5562f437f84acc8f1d86b362625512b0de75f98b2b87817b0ff122a55a1a67aecd6db7818df1fb41c96ad5ee2c3c8b454b2da0f62edf45fc72184b0060b6039c2344f06f2a75b41f1eb0a0bcab0ea0d257cda674559f5f2a59963637933a1ec21a13f642dcaf6d927405f6671f7ac5fbe8446d3e7c052462cfe6532c6c18cf705c6e1cbf98f5f6c5999573609031d297476074175fe8f55cf0e3d995cc5fa687f668720077a0a7d84a3474bbb709329cf06681eaf6dca24279710e93ae16eba67e85deda3824066efbd73cef5ac69329272ff5811ed47fe8ed0dd5cc0703f2a81d3a4bb2bbe524a5922f482342b25473832fce75ff62f628b12d709e2db7ea8d4d802aa21745c3bd2d2fb0fae660e8d8aa35152d723fd82cb23f74761b2c9b502d45990ed52d145208183e40c6912298ba019c6755898adbd8b3fef05753f79959cddd1e6fdad69c25c03223d9c980a95e9439f556a770758dc90c7edcccc286c400e6609d14d2b00ae837a0ff418e80f6988ddd712a1094bf8ade7a01208aefd0efeac27bd57a3e07c5c50afaa94123c9578c0d07c3718921d2d658896c28a55c68c89ecdd03ee1bee185844e048a7b9e3e2d54b04737b3561529a2f90aaa5cc58fdc87abc67c7f8843a15d74198a90de2ed9c7e507837db7d6b00c2e0ea7fc3656a39bbc953413f13ea26887f1d7c8d4a9b37fcb05b524629a6bcdaae924cf0b420e4a7f4a42905ea52f312a8da7019d90f26c5a9d786f301e3cb3149ad8aef25772764b36879e5eb844ffd3187f1abac5ec5616f53e2f6b1bffcaac073593c2ab24ae96848372240359bfbaa4e66b03590662321945d8d947f44b3a1844b5f2274c10d69c67c42ef73a1fd785c065b9a6ec4aa19719f36a4e79b9691b3d1b8a56db9e64798629e6c83db37149072e0a9c894446ceb9d17526e7c821bcf428188b2179f9793daea9aa657d7d05f6ba46245d32afa5d2c55bd05a82b420433e7a3140489190e89ca776b21a6aeb05382c3aee50fd64c27ae9fcda4f503d667b09a3ed19b727d651ef328db5def6d2a9e6d920f3ff61f41539fd9e1e29de50df55c7e799bccf7cf7290d41ac9cb048afdc8540dadd8d8fcd0f0ec72b95bc99bb81aa77717adf0b8ae5ee96c8545a655b1fdf19283d789ad24932008a75b8663a07b447f2adaad3ad7aae84bbb3194551a34df5badd5b92870a3aefc394c30df56d3cdaa78f9d58251a2a020cf867edd064f21d3b3321a292700ca203a6ede2cf58ccf680c5bf5ad217ec8d8709bac58f3ca1fdddecb4430989bd7afa99ad1ccbb5573f198dfeb21403885a35c66553923bc59fbbb0574b9f8c33b3d1bf05476dc57b8876c1611af25c24c56ba742e2520cac0cc74ee04857a14ad24b2e51f0555fd4ad4766cb83178da58ecbd54b33684309108ab6188e44ea68e4d494ab00554a7828d3e417dcf66011fb2db8ac2f0bbb7776b69e73387d993546d5afa0c01b61675369bf2fbbb642f80f18af5a0b1d99e712ee81795807b6e847f0e9f9dff853eeb02b39779cde2d36fd6292389455e890b07442f213f82fd0ca8271177a11138844cc125dd2cc4c475d5781249291bd1a592090334dcfe1cf0f7805a84d1a4ad80147600441655b501ee78cbf6dd7affd74ef13365e46bf2d6e78d5a2a784d3d894232c4e766117d0fbf2de28c73b423253a0e5b091e40090b9cce8921082054798fb9b3cf9d3c4e39b380333cadcd6c9f5c66594323a64b843fc35406c8adf4b7585b6c209915127642099e65d9aeb0c991bcc4634e4f747ccba640fe43f3e9371570b7a45baaa9400a7741b54bc7c8105b013f1d07e26a817f729c3b228c7a66eea4be3b2f64b3ecf67f01a8fffef25ff5caacb79e1e1c6be3b62d5c28e52a86eccf079d4caf0f3c101a76559b2a362bbc9007ce6db7be642e53ac4cfd783e2891d788505702584467071ab149d342bf52ea99d047a636da129a4b633c229a44495f7d72a755b0be2f14ab293acfaa335bca7f4fe81c6dc050b88906432e4ecc7373e4cc8b5245837e2dbe484815be5f78ab245021fad724d350380dc9fd1352f01336a1f63482e2e86fa634a69752cef637b4d87b50e95e32800522c833634f94df75092e8904500de896de904d33820a8462a06009d6385829a404e72a8264d7f1fd96f6c01ce8faf9449cf4cb65bf11b1c440205065670aea201d702a31f07bf3159b2731ed73280e0190d5e468590d5301f04c086da62978b97f7cbf85815ef816c168c5c2a191a675e0bfeddf300a052133360c4f07d23f9e39a29fa14c966e523903daf1dad9aab55d0f846648a973331d4d5d64d9ed91b354c2f929c302abd51cd4ff0ee529b438b5a235131bbcf7f96420ce942931645f7177e2b831620d9e2810c04a26e398ad51a07b457b165415fb5e5732a2689ba890db228a2ce35a11d7f69239499a96465d2c1830a6c97ff25e6b9a19b748058108134e27c85403a3ac6c4d437991f047b6cdfffcbbd0403f664837c91cb8ea35e985e15501df03e6d054853c95f04923d0e53b0de24d1ab8750c2937f1ebf3c6a3130bf1a24aef3c5434088fcccc16ad8638ab958bb080011cd7e2fde75a79cf5230fa57ed2fdfe341e3f4abc681085809a418cb5588e9fbb2420099e42209cbcdd1c842b49708b42061a6b887fc70b248de737c6c611772d214aaaabc8722f4f018a5574d58b19e03540e1fd0bdcca864520d6f6d69d23de3f89450512c9b1fe1b52a1ed55d7e554fe7ee7d900ba7ff0c2957c8c6e5b77a2210f0ac375c8498ca6714ec67a1a33602504cc78b87e9f18e94d52e896f405b03da1a7ce7220eef112cf79b29b66d198d465240aaa3db3deaaa828a9291f8aa2e0b15e9e4dd5973b558bc51280be89352cc6fad93ece4c2137db295f29618a2cb5d435e2ff1fc3ef2eb7de12abda1eec8949cf8dbd5ccbb3d458d666be757305ad3777a93eba436f4a6aafd447e140c1d0cc77b92bac8ddd45612d9ed0df5bc50dabf254fb4302c8d9dce07308fe3c0483ff23a4d0692d6ba3d8d43329b336b071c5edf159a3b28d078748adfaed70cfad9a61b078045b1b9b48fab707616898cfd578316f0ad7420c4a7e53ede183453eabcfb7df23ae00901e81ef63565f5d424d314fa39c855aa98c1188ffcf2dc363066f0e0508b9b0182efd82e6c18cca9e939abba8e6f985fd56eb1bceb015d9a034541e952b440a14654b8b4dc846dd58a91f255454edbe6356866e80004107d7ff3b00a4ba024f9ee12d52d0022015860f2030f9b8cb1c4726d21fc40defe91526a076ce9c6ba71c48b7686d0e4c844f56ac3b1403d04e006dc09755c81920bb8eb7b8d6de4186c83108fa3f0b16e208d10862574d9bd657ea779ae812a951c219554db824b5696c36c3e821d3f841ced20e2c088c26429de6b21f2b73244ac88f26b3441d683412946b3d3fe85a7e8631346324fcea0d94bf64d5d70b4e52bb42ac3a66b76abe0f0eb755a441379469a5e2a766ef7b5baded96b596bc67cab19025d4106b18db16ad62fa23dcef6f9e753472bcca95eaadfae5f02c74336928ad18016f4402e7cea93c4fc9e0bcb4716fbe041755195394b59408807d10a869dfd83d43449a85f6650d2caacede45546844c93669628dfa5b8d9c50d1a087d235bb314e4b0b59429b0776bf92a2d72e9ae7de532f0f43b938e8ae0083821588cb108bac2e337a9c9ccaff634a09ab9f8ffa119f32facd08ae59fda8aa3d085746cf34c1ee9c8279ce643d963f26dd75ed89c43c91a2cc180ab038c4fa28717f2d16c8cb6e05857a183b7dd4c84821d1318b9dba09fe7722dd1439e661e3ba2a3865f6191c636755853c57dd21ae5afe4f4ee7c4b30f9433637c7c7a8c462a27962b3721c02bb734fcc90c66939ef26b917c4e2ca3f2a3f66d5ad5dd398163acf054ab8602748ddb020e0ec5119189aa8dff74cfc70a8b6353e8b1127858dac973f30fd46bdc0e699ab706c1df47ef7fdf607a9840887db4f67b674409e421542a160e7e2a020daeedd4d2aa92d2d5253cd4f5eed27b2a0df5ba2fc983858639455ff27bd79ad8beb2425a877ec18709f7a4c6b9856e59505db741ca4cbbd288083c3daf5e7d2c43b32456028dcc9c49153854632983f6a173fe601bf39b582896d83949d67915b67acf49fa64adc45cd2b5a832c1c0498afff2900173b4a45da926bde3140c213161fb0e8305ab4a8c038d62b9fcd1cfaca433d97c311a2d926a7b36bdf8d895f91e49fe6e6c85a10b10a0257da7328ce8ae0cc3adc8badf252e0034c83196528a2d8198de23cfe411a0134764a1630a56519cd525c0325c2f8528cf30779f925247514da35c91167f6c14f8dad421aedfadeca0067c80d90f94f940b57d3bbdd2714beee52874c663817ef68d53bcf3a7f801dd1c9217714ce2bba8ba98289e007a89973e138f270d8dab3ff4603fb03853d95bffed9d41429eed35f20c8d2ec5e0a9b31e5f331d9dfd6ab72f1260bc75cfb25e3510a1cc438f3d2513bb1d113ac9e3addd27815f31d3408455147f5049796acb2970898a8bc1948f6f9b5198b8e6fae91e21de19ad0791e65260ed06321cde3ea0d13a02e1cb5c8be6325facd82e115d8dd60049687624f8aac1952fbd81c5d7718d330d5e0e4dea5c45cc1a0bcdc6e1c06f8822e6fb7fa549890658922025f013dbca230a828401e926b2931131ed9e3db13d9bf470f3144be6e1514983e2461beebf67e0a4e9cf4dca63f71bdd4445603caa290d6be24d63ed0b25bf45922aef8919e4fdb396f5623142b96352911270249e6a7655fc9a977e99b52de61f983f2989f0c5aa549e671c5faeacbfd51de65f8900e78f08ae96b7ec34856f9bd9431f2d32b33f4e9c1358c9499680655104aa756079ffd5ead3d75e8a47d4cddbde70b6fa0c90ac35d852d5da4c2fdb28561c8eabea5120770ede49f96d31546fe407999224102dcd45c6510a334359c6bb4ae5d557dcca40fcb4f5abe105ee2ed33d79644ee9b5d7bc09a3552e9a0a0776f8c49b2c0115cc97b12ba400ea027bb8881633295d2d4cc19f00d68da0c141d4874e50cf8cd34d7712cbc6012cc66f2f9dabe9a5b420f27281979f8f19aebaf154862223ae3944625a0dff3086ac65d8bd4334db269b5922ce68f157dd4528c544137c1d14f219afaf9d7447231e5a11f1d0ffe8b93bb553c3ad0c9f9fd78a652bb6c885090b49f61ad917b0ff635f7c529667d3371bc6d9ebcda8a32e3b991711f58b3e6714704cf2791088d0788e9ad4ed2688e98b2b78932d1335ae0f194981ae731dece7a780d361011687b9b466c9c61b720ee1b4b17d914568ad4ae5d0f286a5d85cfcd8bcf5150abc1e646c339a47103bbe25401f5480bef433e3f52b368eadb84d1c8973ba212a652e9657c6a1c74fb8ed0471dbd84b079ecfbadcac4d51f091bc9573a7b08d7ac281b6e0a9a05f6f0c372e16ee3c41672902857e8f974c350bd50bde0bb6eba74e6a99af357308bb5ad826454db25974ae0d946fd97b058a2268e3af8b214cf8c390f5f9ce9ad4444f7e7032968ee5078a1e3f976d7d6c61e84b4c49c5a48451bdb0fd2a946bd443789df6d72f44cba16daf0f78efbed493806402f334af67c5ae7a5f1298937b48a9e09519c4cf298f02e2fad50badac37ad1fa22a507cf03c004e8a7f992d0c314ef215e4d0f4d83977986a9ec2bfb9f60d8e8a5e565add06e37f38f58b0b4e657c958b06f15958c2718ff516a2255740b4c244613b2422cfe9e9557d22182e905fb3b3faa3b6292882dc83c3138606cf2c3a43a2522437ad9ed3573637434dfb1c32d43303a918b7398e96bd9c2e2b906f523ce8960fcdbf44fe90a549c0b2d7ba4bb6c18d1ef1622e6bcdf6da5d88fbd22983fd7675557b3f6b9b64650b715772c4fcfebba5d516239a8136b8fc8c26bb8db08a15d2f7378618215e81b2af91380abb60490831f1638cb086b41240331d5ef3a5c37a120b76e4a578d5f267d11aaa865be6faf0e6283bcf2cec8e61a08480ef8a82ee5b9dfb357dcdde18e69c21886019a8ac85ad23a21977f13e19b07accb21fedf0b049d4b928e54096ce99ce87fbf1b28a64278b6b5ff79d6def87b42bd11a6f13fed778e3f2524c3c20bb7e1f4f8258f64403e6a9a9c5e98cfef52304238ff0dd4c5b5df8b009f8e1a54bf902a9694435ff02bf2bc9ee68ab2b1d1de473210be5cfdedf738ca870fcddbf1b956492f749741cd7ca79cac1962944a0884c92303f1e9348f242a642e0f49865aec654281664ad29551afd24761fc2cbf497786d3889a848ef6b21edb0afb78e353f0e34ac25892368ff3bfe206245506721c1f5633e4d28bd670eb7d5902722a3c2a45ba716d6bf3b15589bb0e124e3eb0bcc96f5e528ea5945b6f3a602ff9e6f435ce3f1df530b75a3ff730c45cc0c9ab9470b25240e30fd8ac8f6865336f9b048830d95bdf54401d7bfe7ff9645067189d556809f764b79ce232a02123a4123b471bf218ff57b3c8f683c111ef41fe3b8e1093d23cb28dad004e50ec0ab4352da4cb80160cb57c321d88ffa3912f649d9425dbaf659b5a6baf4fdb6a6dfa9f0d77c3821bb74e8e566ad02ee5ef7f74079af63b09e81ee70c278ef7f360b6b262cde3e8cb420004884c50e7db91084c30fba30fcfb24f472977545efb5b4e8d8ad265f4e7dd6d10e7bbd8cc50cc0b2ef64802a01a94144221c6b7d6ec8d4fdabf2f4d5e4979a03024d8a6cf1e94d957e82597c23d7f5b06cac247dca4fb2d1bc802e57a97df8755764e31d0defd77bf22915252b544ff5d027db01cbe85ef3cf87d968e1b597b5ab2fce63eb64bf74a6b7f72ac62436aac85e8afb2db8aee976f4fa05869d6035ff72aaf006205396970","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"50ad0dee8ce6b9dc1645f409ec5d5785"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
