<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="robots" content="noindex, nofollow" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid rgba(255, 255, 255, 0.08);
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
                position: relative;
                z-index: 1;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: rgba(18, 18, 31, 0.92);
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 40px rgba(0, 0, 0, 0.6), 0 0 80px rgba(255, 215, 0, 0.03);
                border-radius: 8px;
                border: 1px solid rgba(255, 215, 0, 0.15);
                border-top: 3px solid #ffd700;
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box;
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px;
                width: 100%;
                color: rgba(255, 255, 255, 0.85);
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: rgba(255, 255, 255, 0.05);
                width: 100%;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                margin: 0 0 15px;
                box-sizing: border-box;
                transition: border-color 0.2s;
            }

            .staticrypt-password-container:focus-within {
                border-color: rgba(255, 215, 0, 0.4);
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
                filter: invert(1);
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #ffd700;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #0a0a12;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 4px;
                letter-spacing: 0.05em;
                transition: filter 0.2s, box-shadow 0.2s;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #ffd700;
                filter: brightness(110%);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.25);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0a0a12;
                font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                position: relative;
                overflow: hidden;
            }

            .staticrypt-bg {
                position: fixed;
                top: -30px;
                left: -30px;
                width: calc(100% + 60px);
                height: calc(100% + 60px);
                background-image: url('https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg');
                background-size: cover;
                background-position: center top;
                background-repeat: no-repeat;
                filter: blur(16px) brightness(0.2);
                z-index: 0;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
                color: #fff;
            }

            .staticrypt-site-title {
                font-size: 0.75em;
                color: #ffd700;
                margin-top: 0.3em;
                letter-spacing: 0.02em;
            }

            .staticrypt-instructions p:not(.staticrypt-title):not(.staticrypt-site-title) {
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.9em;
            }

            .staticrypt-cover-image {
                margin-bottom: 1.2em;
            }

            .staticrypt-cover-image img {
                max-width: 180px;
                width: 100%;
                height: auto;
                border-radius: 6px;
                box-shadow: 0 4px 20px rgba(255, 215, 0, 0.15);
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.85em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
                accent-color: #ffd700;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #0a0a12;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid rgba(255, 215, 0, 0.3);
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }

            @media (max-width: 600px) {
                .staticrypt-page {
                    width: 100%;
                    padding: 8% 1rem 0;
                }
                .staticrypt-form {
                    padding: 30px;
                }
                .staticrypt-cover-image img {
                    max-width: 140px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-bg"></div>
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-cover-image">
                        <img src="https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg" alt="Cover" />
                    </div>

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p class="staticrypt-site-title">ドライオーガズム6ヶ月完全開発ガイド</p>
                        <p>ガイド購入者向けページです。パスワードを入力してください。</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="パスワード"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            ログイン状態を保持（30日間）
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="認証" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "パスワードが違います",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b1752f9c32293a6a35eeba48efbfabcb5d02b20d8fb14926fd3372e5b99331bc4c140d77b53cab78bff25cd2a978733b0bb6120c9d94749611dbfb1ac10ceda25917537da242cd8eb9737e5c1368bdeb4d5388828e6a128c312829089add27617f37775815c4b0ef5e1f9ec0863bd9a52b8d37e0a4f7a3b27e3172d1ce60721aa72232fc1294f5fabdc00670c84c155e27f189af6054b95460255e4e24c9879da5171aa82d2557e846b783392a8ca5d9488baaecbb7fb2fbcd90f971d213187ba8afdefc4ee901635226ab128562114b5afb3fb993f8daf3bab505519afd553a6081b25b958c99873360520d23cbb401e0bbef1ea37f2c05ab494c5da24875cde74541776bf541282826f1192e4c8df37b24b4998db9461d0b481aadf12220db49d8d56cd2e2c79af2f549213bdc696597c1107eaff49e89536cc5f1d1906155a99ad91820781558397feba4ab154e3754fa0a9b3e6a8251fc233a902ace794e50a1898438a6309a0c3a72cdc27284aa280fea936d9b3a904f68bc8474f2ffc1addecac68af1a67e1d1a2068f59db63b7ad1513ae3685513b140b825261ffc8d8e2018f6617175f3017bc5c6faaddb4c216be5b31838a690929ca2fd61f043afc31554c2ac108ea36a885684fcfebb263377f61ac95ac743a048ea9b723f6829d87fbea2ce468bb289fe38beb75fe4efc12a5eb4127f2aeff7b54127e369ceada01b58b792f2da421148c61137b42fe41c27320b848de24819da1adb2b782a1354a0cfc96f4df712d8b02b9b1ca83f8ee01866b73ad7ac667d6bdf14ba1697106995848c8610279b239f104b48b0919dddec7f20b32dc4c9b888f38e2aab732430fe788baa0f068329bd5d7e43726b565799a3d64b80953797c3ef4c6fe5125098286889480e9f44807bc5969c5b9cc23aee35eed83d284abf6709ee45fc4ab121073ead0eb3b4c09504dbd463f43a7492ff333626914848cee7eca62e5791102098a20d84dbb6329fc036834be794795d466e1d8a7392d818ee076eefbf199a4951628ec0b4ad661102a696531a973d1b723490d6160eb1d60fb8db1f7af689cf1ae68fd7713e4e3a85f43b237619840ed43c2351d9a7b6d0e978cc58bf219f6d3f96310d586be7a2bf25f9f8f503a72c1a8422b29e3db9e7747fb1480cebf446de6fa1477038e6b38a7ab64b9c4be65b047d73e56966111d677b34bfc66f473ceeef9c0f7175232ea9894afbdc1b031e6006c567f564f58597d10edf789f06e979d73d91cad4ad7ff956cd3551d7d4a423b86e41525925aaad15629e30eb1ddcb2eab63afdee92be565a06b3cb50ff6730eac42a8e01b73633205962dee3a37d443b49642200fdc26b18938ab1eaa71218d23eda9f1669777bfc7010d337d7797d21c9036c8ae4fac9fd640fa1647ca09543b44a61947a0f2b739297326aa12671e98ca41ae29696778746f5258d3b6e416737e6d4c06afd9320cd6a1c1d702c4b6f7bb1f43ebe721cad24b5219ad7ae98377e3beadbacbd45e1ba85cf810a46515a657c63b3a7bc9966953e83113b5e930ed5da42f7474424f7f5381d0206c4912005b9a3bbb654f020934570699a89e780685c74a83e36570a717a25e2a8a929ee73cb203d7bd59e133bcdbd7ea96ae703030462c83cc17d56119f539e30e22d7b21ff231c674eb9edbaf0d1e33fc81708e00232611ab249619919faa34bfd8fe511d19917e62c0b470b5265b48393f3c9e4623d576ffab212cb37ec561f9ccd96f72354f8d4405d501ef870d88023efe0e8ff8ee5742e0121729ec64c688168b025a345089576a11064a2d5961282323009517e6bb910e3bf920bf341ae023c5db7764588eca1b3b19eff8866feed704e5468818abd1436e376984dec4ea8584b139db3b3aa2aa94598006434595f9560a0f6a96d9b24518404846d9c57305ef2a87efdb296c7babc502a102923bfec3192fbc1eaea482425c5c5c3ac7be4a8d4fcea9ffe38914f331ebc10f36adbc6ad3cf5c65384518a4b5d92a7c40886afec1644d8f1ec494366ca3c1e57cdbdaf0933f66b6c56cb5342aa72f8b4ee84ee1a9fd2e653817d1b03a4cd0f712a1ac9e7865ffdcdd4a186bff592995f13c5d65d55b8b57b24f969c251d0354aa44154d4ef3092715bf4900dfeba3b81733e09065340e0c1330a57462df8481f1b20768f6671ab945aae6b5570c678e79a01eb4c3e5eace3dd0701850ba8f6dec9651a00b62eba1e1c20fcd04bb91de45c1e6126933d75e80536c24ae70aeb244f63129411b77136136173053d6f1f0095ac468b3abfafbe8bd6aa8749a3e4a11395b75f7352a96c7486a135279254b3a6db892285a81130c8c0f5468eec4286f5a518daf8b47e3d251b84ff8d5d562f318cc56b9d58e293dc12add2ac85f67438f0a876faf1c309ce760c438c0bc94b57b18d242298711d4ac65579ba5b9fa0c77e017cc0972715b8a85d3624f9bcb6a99625a85a9d46645c33c0d05599c3aa957f3a7c6b2fc30731097a90d1dc3f2a632aa2109eeea9f066c08f36a5cafaa8ffa6048858dbebe3d7109a001dd08653be2f3068ce755632ee8832558857f2c929d56ddb3577dbc532ed53da059e5fc714164e50ec1116daa02b21183d1c84488f5dc0fb6368d4950b1cba741bc9915168bbbf30629caede0df906759eaefa414ab1a6ba8e8825136d4e8e61d71b51e262b2349df04a566f6440abfcdc416137cb1c791871c9f7c65bd7b340fe5f047dfbee8608e2937e65c3fdb0592c650468cea05edb23778c3758bef74a161aba300390239adbaa59a8813a64ccb52a13ab196d04711f10a5a19635502e93eaf7431074706982e2bce6be0e8295ffab69f24e1423a8053d14c76c5ad5f0d67743adbd24e5b7f828715a9bb46839c1a9d5a345b39770ef910fed560514d3700f6e3ec2f2a3e9c3b8ff309c2b2a54355d15b85bf074012426875676d0212d8d08b46494782d0972f2d48e9cd2806ea41313143426147c351a64496dcbc00cf0f33d4580995897564a6d3910e8d7ee530312e319b1466052826ab52fbde048e65aed40b4a843c8de7674b9cdadd3fa3d412cbca7769261fffd3b90d46f753fe4a22ce43a5d8db096bd34c5e50633509e716a31a1e1d07b48d051f3ab1b07dd5379082f54d9cc48d5bbba5abb036d4d02d8885137161305a9f2bde72fd3cebe9e4d6348f1a9fb5826d52ef6c6190b85d568008cb0945a01a654df089868c97dd200cb7da2b2dd0f5df93e20ac4a29abaf9f9d4c682809eb2b47b04f97904870e8eb8e0677ec5217f3cf25b6f47af8820a31ac2aeaf27b4377a14c800ba3ac09449b45e3ac0670143914a30d127fe9283c6d38336761c7b5cebaabcfc498a31f403571b562aca7fa399bf3eaf4b4651334c7fecf4b15e5a84ef09c82471de544ff97c8de4136f4da31150b1abbb200eb08724310350de1cb2bd77e70df47bc3ece6de14e735823c57d823b919e257282a8fdaf0cdde0b55288435449924bd67d5d877efd07d7f2f9935d2977ba325ce7de2639965ca56af8289d55072ac774d2b44df3a31ddaacd97c7c72f6cfd9e41e56dfd80f13b15f0258103daa120ade043926b251dd45a9cf089c12166dd0caf49abf571c5b7df1ca238aa262af44d3936f5dba88c501f99b210cefd3fe02385b01e5c3ba5b4ba850ebf3e56155bcdc8dfe813561762423a898ee84da8437b8a32d18bb8b1dc60a1ed1441fe9d9e922a7c41c6821e9041caa51971c2adcb708f97547c19728007812d0474d69402ff5ed6c2fdf95a1c523823bbaa8ca94065191fae31b652a9b483842e0c75a35e10fa8a1fd710b3b9cebc64412e301efe4f43fe8b664c5258456d307fc95b18b795da0e1200397b50288db919e814f6c99fdae30640b07bd093eaa14f906944f96bc0cd281dea6190b85c4d829573340cd427c5925d88d75815485a92bfbf3b3deeabb44b8a66f217b44ae5df8b0e8b44d928e27fd5825eacd23de4a70a883d48c67e2b94aedbe6d9af6ad398294666d5281f3f9541565030d8783c9361905b9ff3e72b7143d04b1b4963baaff5f2895dc9ea5f89a4567e7b1e1fb861551d828d491d88aa06e5dd2dffad8f58321b3b485908cfed7e085fddd17c24276df36a2a40af6acdbd93888e13a15c857e4f78d70d14b073172c4ed21da00a7c14e1a26074c7005510862fd5a54235d80b84a0b92d4fa5a974b3f461f01cdb2ee34e93de38ff42114db197c66e2ec5fd10894b9aa2c0950a2240109b754fdb81d1583275de322d2287cab2edad90a54557a961bdf0c86662305b43d8c129aad8f0c7de6cc2cf98253a0c371d362920e4fdd020345603464e821ab92b1376690781816f0c794b4716dfb27e014ac1b3a3d1868ceb57d9099c27601660ac2b4876d8f176d2737cd9a9889c298e0d86dc1e83baf66f1c00e848ff1a15da97f059aa400f59154794d0d5873a7ac2fd0e99143fde5c70a79e6f26db2c1a47a721e09376aaea283ea5f0676ad843ba5d82527902a9dc3e58639d6035788d37c5c5bba54c0a4b5c6e9a56a04312650611127a37a298c2da01986969a4c4b5e9a63ad781dc6326ae49b71b0783e44a53584be383bc7b6bbd78a2645f208a3289049854b99f7c6a6eb928a9b256917ec12ad322204ef3c8f3357d91518a38a6a631ad520f5bb017d220fcb9f24464d385f63272a947df63a8448223384ff4ef1a195773adff0e528d89f0ef69cc58796b73a7006265ba65607696782790c71c8078a01c58f784fa79f6835234eaa60b2a0c9bb7f8e66509b0e52f8df9490f2e79f7925d4c0630d4a98a5bddfa539d1251895d112306e4ef80179bca9e976198492d3c41e308fc4a2b548e3dd39f77fac1dce3b35031fc0d1f9229c7008effb1b5ba916f1c0e9d7a8686fb274cbc7b6dc0af333795b0a54891f9c5d409e3912df759ec7d311dbbc73484650661b286da252bcd49785b223b63fd55fc96be4461db408c20853cafebf2eeca51824a142744212c29543f7fa3fb40f460cae9b202675165d8913a471576650d4bc835800757912ed5d3e20a9228ad6b665650c2a9020e410d4460b5703d0dbc43fdf8417f40466778776c5aefdd7834ca9f05edba115623bc463238879e1836010f59b385ce61d7159291631bb0fb8ece8f8a09b0b02ae258f8672152a2f7ad13fa322730867f70c1f46b97cfe06ac329ad7deb3bb73d1c7f32573a9f721de58a9f1db13e3248428510be62058215adf877e7af6996fd33b97153cd114a45aaa45ef9dc7caf3a5adb3c0c1b329cfc9d4e233852c88feb37eb154137bbbdb6cba54210314d5a01e819a9651b873353407e125aa53d2433b70876c4dc5b9750540067621f4ce6df2b824bd958fc23f490e319d30b7504225252f56f7b89088cd9a1341a259729832362a4e7f73d08ffde923536b9248ff53dd5d36274bed3e974b731532027c55d0b3681c1ebe47c165e18f2cf3b325008a2b217f435825ac698728e5d4b86063832c6cfb59a481f991b011f0ca46a9a4ed54556080eddcb51a19b5edf9c55227afcd24b848b1b73a7673373ca11462bb6762302e23c3cd669cd0036d0ee8c7118e56ff573b585541b46ec082ba76e54925fb610bebb542cb32f638674d14faaf72dd64d104a9f31764c5bfc40e56634739e49f127d5a592e4d9b5c9634302690b3846c8965bbe8d8b0323c3cc6312810c1ca416c0bea226f67be082878e15560ef46606e5ee438bfb3489a2f7b49ef04fb9a92e02a6791e833a2f887646353d344b25d375abc7a96286f68e4bad095c69c13b38c761ad4c45197a369ae8e16a5b236ab06c7b3e89d5a02c070f8bb7b985075fe6ae41467a53028a1c8124f9d8efcc9933cd2ee4205507bb8bd5f4feebd4c1da21de18234a27a6f4bf33248669f65900b55c6f047b662596057a8f65cd7e59766e67fe01852deb6b43b39a48901bfd5cb929940db8a39159589abf187928a7c1fd9902cc8fdd105824032eb39d5f60c0c0e1394d6e05a72ebd38eba6ed66a76597447d6f83e172f9525280830ae089a4e3dc29cbf2a1a059a675a5705b6198b3c07655429e0566835232b70d870f74e32e5ae9ed01a88875bd83612cee52ef98cb40125903d71cbb60ac1855f513e8f827856c13a29a87ee775be78a263a8612a02a1718f305fc80e1a60d5ac7371e8ff979d5905c2947990e825da339a5bc10cf24d5470598669d8f3528acd4df219f465fde5afb88bcfd97d497df467c885160e667dcc1a32c21392971d5230cfa89fb8489310bb404b376f99322a61dd075ae7b90c22cd30385d97451b1b8d58d25e7a4f357c8c9731836bbf6178aa9336b005dc3101ae52d4175e8c6b639814193ac82117421e4040e7f10eb4916e4848e1dbc75ccbe6c45d4b95df7f3b2c82198603bd87468f7a8004d4e7d833c55c722352427faa95e4c115b922e79cde0974d4c202907990eeb1cd2ac13562036df410be8579352463a1374be36442407ce839e1e8f3fbd50262eef1f12beab3192549add1d28af0716db88855d8b39ef88ab9143da09fcb310128643403d114e93e4576552ce8ff9de86989ee8c67ae1f270ff46fcf5d7e664c8b0e48d3beb5d4f2355cc62b9480e97d18a3ca8a7bee1f25e7f48c4c9cc22f14ba1e2b3c65ea01ad1abb3b93073b314870585a6f021b10d951edb2a6bcd7be08833521865babb6ae67f99c2f292bfa58f777a46433fc2f11ea32b35ee5ac0c821fc36accbef1e5ab1b37fa375d18bd68926945d273ea88fe2c973890c42615241a1c4ed15f243a008b42976b1c61203ab07d25833ae4e97d19f22cd92609f46bcef319d4a08fa53098fbf8289deee97e68cd6d0d32be911b8e3b6557ea5084f5dc4bbed3f46de4992899b62343513be5d0dc980a5955bf7df9c30f87bf94b7d0f117a57d3ef6189f02ca8ec50d5a08af455314f2c5319241a0c506d68541aeec0ab87b31d17d9bc89ccd029372ec2b65cd2e0c5730f4f667f77ba6e700f75d3d6bb6cb57f400acfb02dcbd8d81472af5e63aafb3c52fb688556915f850f8abe8a32fac3810b445a7755de830c5dcf0fa3af182da0fb1e9fd590076ced20c5d6940c874cc8fef384f201fb3abcc94ab72b8222c73abd282c24d7e8325a18060a6a3b835f743f9d04c27607578b2f1f15c19b27eb046e45e94aee1b0665bda8748f0e84813e1cd950ad21f0e4b823aa89c63fef4ac43c2a06a952c42bb484915743f7debedb427a91e21ee944111d0013065e09c8b80a89a968e9504bddf024b70d2d49d96ec020f2267a83e42b73096d6f9cf174f8e3ad2e4e6aa462600da10f12f55257e86867eb5d9d37971e5e2620c66ef6a8344650d89bae0f7b3433292a9b4faf8922a23824c2b6de7fe38a90bb370366e7d1e3fbfb88b0fd64846dca4395d57e3912b6a4789dba063e12f58767cd24719aff0c0ea6a825cc37c21b79d8b7f8aec428cd57be2a0d6d9cbc55a8add2df726d20fd04fb9c251347352f3a670036ce1767e6acb836803928e88ad90223e8e33dfd22d1efc1286da71b7d2e01157b40ddef9fa6450fff1894cf8a765d36834e6517d4c828c2fb157a1f57502ceb3a75d4393baed52a0314537d50e4591077dab3784b3c43d3062f11f51fb000eb1c3ef81c9cd204a73d9168db4a1f731932d796bcd9eed53f58f4f55769179a8a15ceb1a5e412e157102e200f09eb37aee129713db6a90f57fd4fb94bb8c034fa73d2f24ee2621ae56669ec80c92e2baaee8d23ab6a3e975b80591e53bf9fabc4bf0123f2745953602bb7d7d8c127b5708919824731ee211bfbebd7e17ffc63481672548ef267804d74fd86a8b78d311ca47d0f433e760d66b65bf44f9cafa29ad444776a5034c54f36d976cc24e316e976d739af451f61eca1b2276f8eaeb3d078d33727035472fdf299f141df6ccfc15b1fee8fc0268098cc986ae3b973a805b4f71bbdbfbea7879a28b210dbc44967e8d5cc06def2d137e378f80ced86e518cfba27bd745b70dee9c6a22215d3d409568876f03a68fbbea94b6e44f1018cc84e8612f2900b316f4cd03df633a8ca9fd6dfa8ac48a1ee4af6c195a442fdc2677e167f471184cd70bdbee9a6889bb5e0473e1052226e07c20e407c6daba312919aa4d27b26c5ce9526bbbb09b59f40961b7e5aa8f959bfc671df6983234d31245ccfa8e4923a1fe873214221da3aaa336425b87a7589c43e180c154ab8e8bec222a64329d1ac78bbca98196f066322890a529e642450d5476f89aa4ba98b58e2e08d9ca27204fcea5697229bc527a48cab89f7f89d875038d082c56e2481e276e712827a747e1eb2e701813370dc5fc16ac04822","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"50ad0dee8ce6b9dc1645f409ec5d5785"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
