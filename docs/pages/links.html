<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="robots" content="noindex, nofollow" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid rgba(255, 255, 255, 0.08);
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
                position: relative;
                z-index: 1;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: rgba(18, 18, 31, 0.92);
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 40px rgba(0, 0, 0, 0.6), 0 0 80px rgba(255, 215, 0, 0.03);
                border-radius: 8px;
                border: 1px solid rgba(255, 215, 0, 0.15);
                border-top: 3px solid #ffd700;
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box;
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px;
                width: 100%;
                color: rgba(255, 255, 255, 0.85);
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: rgba(255, 255, 255, 0.05);
                width: 100%;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                margin: 0 0 15px;
                box-sizing: border-box;
                transition: border-color 0.2s;
            }

            .staticrypt-password-container:focus-within {
                border-color: rgba(255, 215, 0, 0.4);
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
                filter: invert(1);
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #ffd700;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #0a0a12;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 4px;
                letter-spacing: 0.05em;
                transition: filter 0.2s, box-shadow 0.2s;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #ffd700;
                filter: brightness(110%);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.25);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0a0a12;
                font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                position: relative;
                overflow: hidden;
            }

            .staticrypt-bg {
                position: fixed;
                top: -30px;
                left: -30px;
                width: calc(100% + 60px);
                height: calc(100% + 60px);
                background-image: url('https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg');
                background-size: cover;
                background-position: center top;
                background-repeat: no-repeat;
                filter: blur(16px) brightness(0.2);
                z-index: 0;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
                color: #fff;
            }

            .staticrypt-site-title {
                font-size: 0.75em;
                color: #ffd700;
                margin-top: 0.3em;
                letter-spacing: 0.02em;
            }

            .staticrypt-instructions p:not(.staticrypt-title):not(.staticrypt-site-title) {
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.9em;
            }

            .staticrypt-cover-image {
                margin-bottom: 1.2em;
            }

            .staticrypt-cover-image img {
                max-width: 180px;
                width: 100%;
                height: auto;
                border-radius: 6px;
                box-shadow: 0 4px 20px rgba(255, 215, 0, 0.15);
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.85em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
                accent-color: #ffd700;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #0a0a12;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid rgba(255, 215, 0, 0.3);
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }

            @media (max-width: 600px) {
                .staticrypt-page {
                    width: 100%;
                    padding: 8% 1rem 0;
                }
                .staticrypt-form {
                    padding: 30px;
                }
                .staticrypt-cover-image img {
                    max-width: 140px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-bg"></div>
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-cover-image">
                        <img src="https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg" alt="Cover" />
                    </div>

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p class="staticrypt-site-title">ドライオーガズム6ヶ月完全開発ガイド</p>
                        <p>ガイド購入者向けページです。パスワードを入力してください。</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="パスワード"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            ログイン状態を保持（30日間）
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="認証" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "パスワードが違います",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"35c75e2a35cc7be1909e8715c05f19355b843b0b8d67f5907c8a392aa0a0be31beda9bb57f47a1daf7ebdb3717201cc6b176dacc8a7e51516788a10287f0ab704ff3d213ad4613a42e34aaa4b035c396060e2b09fd2e20e44bbc27432835128527d5d9374e74025347051886ac9ec4a11cf39384ebfb97f873c504d6ad9b4345602e05681e90694a447e0a14e8ce51a7ec7b39d709d93ce8c0b1a103828a308549ff0a4d67eaf62263547870c37dd4fda43f7387f85bee708c816e742472bcb31b177b5dce6f980467b75a633bd76982fc1fea02232f33dc0a1fe379002c049a533f645f309d02abf03c660dae4843ad93219d2124cf1cc602acd743869d3fca486f63e5795c87122ccd967f2acea4e054fdf3c32043ae6d15740d85e53ef4db188060f3c1e82b77f537d4792639fb95b7134803d3a1de433966ce50bd8748d902d99ea81d783db5d0959fa7068f4145c7ee664c05a713258a7df7c87a40b466837eb849167ac8599fbce37931de8e7ab5f8689b97792ff6b21360861f6535fe456cfc836547a703bea2f8f812b1628be8dbcc5eb8ec73307cdaac9e72628dc71b82933bf82915960ec9ed0ca3cbcb720fc8783480e3bf4b978011ee7703c9557bc9d07a3180a5b7142d878ac1a4dae125583bc56a73451edeb47e416c0c652f314e4a547866cbded7587215bdae6e72d7e131cec67ee67b504e07b103c2423ec78b19fbb0d2215e87d1a2c5084a0f59b1785f7dfd3cd4b914d21b7e572de4b26fe16398bf993004dde0bfa1b0358b9abca0012ddd20d78802c0f3e1028eb46a63e3ab1a7256314088ea1aa48141759c041766490cfe11b01ce671db4adf70234d54d1d397a060e37b3e3e21b218bb624fbe7250b0745b03b807dff9b1c7a8782a589978fd2bdafd8dbe14d24fbb1d0bea43ea7511f2b8e8084df5f0045b8e5856873e5df8195565f0a756b1646834aa52ecd46fb0ba6fb4568eaf597b66459510034dc954417c7ded95dbd724ca7ec92c2768f000630db80664e28f0d3beae806745fc4244921667871c77f02428e5519564943b37d4c15cce2bc1216c69de9649b0998bd99e50e8dd465ccf00f3109595e6fa18b93161ba24b51b69a20da645f33f58c480e5f0c601809a1c978c56f7c086dae674d1f97a7adb040ed510b31afec7223526dc8e9a63bda5407b121291c87f098c82efa487192388400a253396ca185fffbe2faffebb5b197ccdeacc484a41dbe455ce61ee3c9620e100e110edf57512632e8885cf7c85999611a8317bfbca53edeaea4097d8607dff1e71be2b8ffd91b3094903003b8b2bd2749e03a960d22a6acd46c432b853d2cd0697d1d91eea0ee3dfbe180fc0becefec7bc1a8d9b24f7b295d8e6d56ddc77be9af3a6430c9fe48428e3f59994222806bacaf18d21518602bb01e5bb9a3c9f15f49bb061bdde1a631d620e26006f9606e05673c5b39a02207ec9317b6f358575de4321b6bc8ecbe20f6a22f600dc2d7092d4077e0f6cdeacbda37c127512197ff8f12fa5c0fac606359727e0bbbff3a53e3c766b92c9e50a0cfd34675ac910c1b3cccf45025a44c9d6f80f99dc3455e4d6b456ba60f6107672f669e9e65b3c0ef7e109d1dd6f1d17f227c25bd5da4f0172eb072f1b2383779c3d8bcff12dbc38431f513e0a29724319c6e7565c3acbde0be674526477bfcce92d1b52c94cd62001b3b9fdad24a999c9709a32d96c53e1f21fe5fa5fa14440610d8c1824bf2e8f4e09885de7086691cbadf269fca97b10c0510c904a29ada4a5c6bc0046988920c93b24ede100dded9d3a98c2763d8f6e9556c258324b1b20a64df0db920d8b51e0d97203127151110c19c147fd18cfd0476010d730c15b489cb7b10e5017842d05918679a9c7533d83fbe4af8fc5e4636400627d72546f666a16ba4c923beaf5e215b7c3181da01cb772662acc7efcaf56d973323702117ed88a73905acdde4db15741452d25faeb7358242e64036809102db4d46281fbc2ce8fccd4b715ab48649b8fd6727e63a65977188cae3d7584d6162cee6ef9006ec0835914629a145151f3ffaa1194564f59611760b615221b990c9466fd134b1c67c297c64a64adf8b6b4177a137b899b1010b3b7c41f33d540a0daef69ea2b9d3b4d3327909f870af501b2b9bc02fe2c4c50d9ebca239ccfb4f9f83ead4dc40fb20abaa8187a6de507b30dc582bea6d2cbc84035817c5ffd072c4e8e0d395412208307ff7263c2791df259594eef2a7e5902de38660afd4892f135843e927d45e1dae04636262617197c8483ffd5f9f471d1a6fef7ade6139a24314c328aa8049127f2ba90080f16b017202b673926cd1a9ddbfb293ab64b06188d793f934b6174b341b2ecf13ef072e20ef84a6ccec59bef5197361228d9cffa29d0d1a11c4a32470d287c1413a363cc57313fbc87cc3b4f22278cedd9ae3a41298e2a6bfa468ca2d3452c507b726a3c97ac373ccea1989fadd09d9eef5a3b45ede67ffaa61d54057c363e50a49507d4373b1677096c0bd1de2df2212de80859c96feef982fec9e8df6d511758144d3b1cac1fdc004df8c56c18c059b3fb89a5c005c564bb6f712f5ce3932621ba79dba93319c3f555c00f0554d097db4a1deeec01193f340a77f1e7ff0cd4126bc181ab1c395057542b875e3f7327973f5d7c123eecb05a6e34f8adff93c3dc39604fcae21aea201769f60a936e6047e24b524d496c8882a7ec1ef6834753f5b651262e20a650ea6e49579228307c4eb6d16ea52b7a43d20324b83ffb44aee40a184b919273c37d10dcd6b979ebef04340e0070f97c3662822be2243cf8ce8ff0a06fe6cdc546f7646ea89c6f172a3334ebb854c308edc29dbb0bd2de92ac8ea08d60c6fbaa8135dc826f568031894fbaff72e03d4c6097ccb949a11397169c1ca306371af80f612f9e7f3f746142e0115a59f50f313e45215a4cd23e69f83fd7c727738da4b9555cd26a76134081d1dbabfd75a71bc472556468a7a861698c06e5bb6a8a943c777a4891c57c3679517f34083d4342ca630ec2498e10e1ca935ff2af2571e64a1808cf787356ccebac106aad15f98f1ffc1036e6780440eb749553cb55ae862fbd617fbfcf7d5104c4d4230224ac42c0400d91b84b4a572af006ba068e096e39e5ee06381f8a7a0a6da07a36bb1fc938112b4c3ccddcb822288802ab8e085549fb77695284e041c1ef5d94fb8e79c59567bcdce8ea8ca69dd91f81c9a7f16514d70cd6528e7034cd8b40a5d0dc39edaab6e0ae715e31ee5ddb656d81db8ec1351f9c90aef77fff6cef6597d160109152dc4183fdc88cd9521098fb8b272e31adff4bc0f526a636e81820afcf87a4b9e184c8592fcb60f3d225db9a74429f52e505fc6623058503497a5b3f0303f37f58a37af774e3c410db138bb97f4d2c683e2af94f1dacc0c7e741a20913f91157afdd824cb8c9a66021ee7e547a7173b7b0a57e8f8dc2c39ace41b105b74011320ceba3a0c08f7fc1f8e01e0a03eda1183704a4d57c203f8af76e9699b30eb29656c6a789cf9185efab11b03acc0ddc8e64f4a317d1b209d2910ff1127b76ec9f500cf28f503b75a5726566339562dc9800966ac40671406e03a0211ba25406c8cd4b1d415f8064975de4d7d1ff965e8ed2a791e2e0d40c97992ac940fbef11ff332828ed633e85eb56b99bab234d0ba074faaf47522624780ce2e2e8da9df52f48143827f3028f8760aa7fc6a85ecafec06e8780e3c630c1ec9b6ee52d1724571ca54690bfe49b314ad5a8f7dbe5995ca91bcedf5478140256d4462454daa9351a193bf59e86b2ff6c963de943821cee8f7c3896f394e86e0ace0f76ca5b0e0a92eaf297d767b42a25dda92c307137a6fc0e91e5747cb95288e80a51ace6307a5df0c494d51fbceb34ad14f07fb07aaf2bc3226a80d24201ba71a87f8e4a8cebec49997ec9625858cbd1431256b5b881d566500b04acdf5a5d3bfe3a74bfbc466ae8a56626a2954634aac0ea2b0e84e7aa6f5aa0cfe91af187a7f8ed1876f0ae2c67efb7f055a1f97abfd61c2bf7895211997c51edae051c2aed79d579b5e1bf59282e3aeaa73ba2e7fd23847087afd4a43dfdefa9ed0e4d2b318017e3cacde233597a13714317e30c783f47b8946288ff75ae5428c01e819f194852e3f0e216dd76dbaa80b76738893bcde7d5542ae8174a203ea88dee54749e1a65008a0af1e3ae8025bce5dc54ef1c6c9a94c0546c9b35f7c55fb858282ea558bc702d909067b1f48225eaef16a0c2333f2da2a10c1e1d0d739da4083c128bad92b59620715f3c27c2c97f0be8165592d4ffcd5e3ee4622658cdd3cc92333cbc89ee978362aa8155288c99cd785ce7d6f797e23968028da02bc8ee75a59bc794789e720108d549fe4ec9c69d0b22ffe78c4d357d55ad19532787e1534681a1a637444f8fdd11f293acfe1f09d911c34ad8bb584eb4c07d226763e19d172376f1cb9a58eaa0282d7c4f154e5977837fc93666119a70e26ecadfb5873b1875f5c958bc03c054ec71578a131c40632da9d7f87411ac44ffe6d70a5bbfe32ec37b803a571c8dd1f5886b19a9474edf095281a24c1512146c35f510c49f1671cb87fc249b3127a568d230360061788c70bee878ceb80c728642e07fdcd78ff8f9ae9a94cdf7908b1f15bea3be4fbdf24c78cba3f45fcc7cde5950d02c0afba9680dbb413d743a8d627b5a6fe8fc5babafe47b080bf6dcf42a214f828e06509d1ceaab2ed8b6fc5ce6ea19398f7c8fa3488c9f7621e675fd95c9827e91c22811c14ff855f439441fd4680ed96c163e24a42f4cfc97acf1428a1f527ef3274a74478b2e73278189feaf031e4055c1eade41a660a33d1e2ef9366fd4faeb2694d203c640e1b2370c9b2f2bf3dd6e2e0eb6101e57c05eaf151c5648ed02e33d5255b6966ae123c7851a630d95d576f94309e9584b424b93fe91546c4905b6fe430bc63806bacf5a2f0cad2662e4bac5db4d96bc97bbcfd8d0f74861aafbb852d227c0961f9c8db165b8de16fd4dba7f90084e8b5d6c7f5db88e03b588c9bc88f18aae00119f1ab3fb32924a9a44c8934af3007623dbeac2b34be94d6bfe9f5e76ebbcd1a72cde8cb462a83b823012960e80a924b256f0ae9a37059e679969e251a5fc6a08d46f2e5c23d0ffc80a8a22f3328559142e669c3dc3a52b3a04739745373bccef9119a9d913f65ff8819aeec3ed61de3f0ba1f3ef755b74c3a1540c6a5d7a9dec3d59c5b7bff9089ff9784dbc30d97c84a7d040eda1683eb2753c8ddf4436e65072aa5b3cd258bf6a0c727ceb75b4e07475193b91dd5c67deba3792e484c94b5278ed61062005cdba35a237b0e08dc23615afb98886e7e994e2ac43f140fc374b3dd12fd701d41fc25dba3df8871a36ba6e6319ad616c0f248adb402a045b4aaf8f4ecb0093eb8431ae2a7d6c588f115ab3a579d4c6318fa265f78858726669236983d014c902910d009b498e1f6f6d46cbd3732a4056d1ea7a55f8349ada2803977f7acb318239eb0aced5f0998992cc2f75bd46eaad8b5b560ec23ea93ee3fbd3fe51eb573c0298e33ca5a7ee8fa1d7b7afc1689e63310a838a53acf9b3345f5880973aeb3b6be7eb62ad6393e253f6de7d9f84400fbec31bb1348925b477698bd71d26cd6a012e814698346abea03498879761ed1f7e9c7fa7a0a80c13dc3683eb3b219388dbea316d07f7df88a506b5b2822b51690940dcc18cf7dba6ac995c57ec9ecf4ac936d56be10b543ad2f0cc9e26d1a2aefed2d61d8fcd09073b0371e2ebbacceee90f1295f2ab7f7118d6e9503aa62c8b2883b894d5fe71cfd8a3c9eec9b8cba62b15b179b9352dd8b97775268b2831214309029c495b86085882751eb065f02b5530d342052e1aa6b15cde76f260abf99f945a491d762bac1889e7ceb609bd4161dff96b3ee55a734ca47facd3ee0f8b361e1c802840682e0d657837d0bce3b1ac8163737d828b1be4c36f96e2786563b312dd184ebab3f1d8968dcc0a574cabcb2221d20ac6ca573739e16314ddced0684090a6d8221908ff5dd0ab323c723ebe0b0a877d81143a9319f86621a3ac592cccae321ce27939878d12f869be00e50b09b1359ca211c04afd395df41f91466361bf82d6f6ae05937972a2f36d49b8318ca2d37f27307cc3b6d8e35f7412a55566905dd4b710bdd2b3029d586e9b76a60e8a495ca170a2096f3559425f5b2358dee34cc794b3fe4365c71e88a46d9f9762b45e8ba75f6b141fba9526faf497a378aa3bbacad233298f12c82deed1b6b47586994787c8b2792f9a54dc019df91af8a3819a963f51cb4795da783182e14d6bbf26137bc7b587435bb4fb142ff3705a6bce150786681e7bc734f93825b2eda69b737d63fa92a8377b031fa2a144758242113262ba308ea29d502565fdaa6c695807fcfaa2383948c9473868d49aa87044b23d87d66c4d37619c76fa83672c49f7272564cf48b2ed9def3e6cd9fbc17068d8c9dc0b5c5ce5e0c3a715de05b00d4d1e67fbdfac9c5aedba844136ec85b18f234617edafac264dc0d9bdce7b9cf01173669ebcb47e7f680a115ecb41910d86674a4378a241c83d13514a386d485efca8d53598b3a2e6a3238e61d9f0609084a30bf3cd08a0722a6f1500633c063c66aa00897932a07b6a7ef90d502cbe041045b35504c58dd7b6729931c1e7197c5b91b616e969530d9be202be93b86fd40dd1fb9b4953762b43f6b72b55f71580e6944b7b00f7b3e17f2cc5246523e7e195a2dce34a8cf3eefd334c3a2c210c69b5ddf1103ac39c8d5d62be570392ed99f11050fb022c6c6769f1ea2f589a38f53ee863019b6b7f9d7780981794393f2b91c41651c57037105489f4d82a87350de89a5849eb39aed51c6ae5e2cdb45455a16ebd158c99aef70756e0dde8cbb3bc2d279c4065b19a3332e6dd8dda0d40e7cf936f7b1967baf46a5bd179297b5d45c517ffcdab54a56b3b606da60502e4947bb150a882abed12aea21f058db722a0dac36f3adaf634d4c1a67fb336b41f8f570d527d4760f1deb2cc38e54752cc82d4f7b07868ff2348ffa9191700f4905f2625631014e71926a973ec7477def3fb2aa63fc053056056ef9b3d9e5d3c62e4d6e9275e4e2e4684d897edfd80a7b3756735770908b01662e4b60fba22a3ff95c241ae534def6a5c5759f5a2da383d6c7339ed18d802f29b8530dcb758056739ff31fdf2dd849c1f9279c78767b3bf985020bd1343431711463327ab8ec5ebe750ee5050510c08bbb3cedbe5e4d6209134190ce53e1164e41c4e8fc9c9206a59b6aaa9a54524328eca5771984691d76c09c40ab9556f003f2ef70fccdafd0a4a6ffcd3b6e8c6db09792e90939870e04a04354ba6c17c48ceaa285f5403ca51676a4b39c985d29ce5e50e9927861bde021c911d39e1e8811c82c266993fc3515c0542a087269312fee8145e5302363a73d56389435ee6df8814ff4188ccc8f9c5fed6a66247244128e722a3774e77537223f30c89f34718481a6ee03f7e0c3fc282925a4cfbc0e335f4c541e3ddff035a64f09c324e73cb7603a5d9a3935fdc08e90e1aeb52872b893da57cf6b998b31cf07707d62a7bcd0f2b6242d756975fadfdd0c8ee42f9495847b47a4d24e24e8eb6e82b8b6650ac15518603e9b440104dc0c4ce033d8146a1bd8fce987fb4514f38b82bbd72cfb8e939ab6c7171adae94d50d323d1752504d208fd74477081ed5fab184b671bb413686dab4f64bde16c18529ccfbd742bf21e8f797220fb03a157cd2baa4b90728be28111e67156ff50a76824f4679f3e23abd3f9a4c7e54b1340f88f71f5f2aa4b7f25563605d8212394a8daf9aa0bb76681be50cd97795769fe09cbe9c241eb2712eaaef8321826fe06c2d18f9eb760506ecf02e94cfa377336c2d5c354f15d7a883679809dfe9f0301c23c8799be57032df3da0a0bf5e0509d3a7587febfb6aca1d91e18846c62ef0bcde4333cb8a3f9049f3fa5efda319b0cc96a43e5c8f74d8ef47b7dbe16184ce4f283124ef5057867a4f3b47efc83b31a7979259b4fbaa3186e53382bde055a103dcc3717fcf6fae306f7ed566d475902fa37ab6371fe226f3ee5424f89959082fdf42b363cc12aefdf53dbcc3d96b64101a98d85a3e3f29b2e7b75ceb30d12ed80c744fa4c64438726cc93cc9654f4543ea9749577ec3eb45b403e97f6e8f77d44c4f833276fd1347d21fb516a95490054efbbf31907dfba7c95a5954f07eaac9d1e2999fa339294a9d6b1c4393517230d735c103bed9db1da58372f73482931a3a753c75feff928d48dde847d70912c55067d872e146a86f3b284b3366ecc9a215b13057534fe1c2887a6d1b27c0270671f869155d35019ba22a32ebde9821ab1d2b9bdce0dafa3b89d89657de7895998a163c7e5e51dabba7c0e876a16cccc14d3758cb11a60ded46a48c17fcbba3a99cafa9c80bbd68605d4971bdf2dbef288ca256a9a0aa4be0f70c76cbe0a2fd2a90b30ffa50095b4cd87e5e6b1b0b636dc6eeda1f8ab7e48ad34311071c0b8c4fc88ca277e23f6cd3338b24f4d661d8feb9f092a2d44186f5cdd3f4a8236a6acf7af5835a06d7e6c32053ce2fdbea0f879c173fcb1c0e5567d58f069f97ac11cd33ee38c853d4a15f2bb5e62872547b405c49fb0d572c51daa78c1980fa77737cedc977beb183a0dd2dcd64fbffbd7c3670a89c24f83f8968bef8e9875e90fb8ebde45562caa3557e1cc2fa3b7102334344db498bec820e42ec95fdb9006b912cf1feff2dd2769073f0b31","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"50ad0dee8ce6b9dc1645f409ec5d5785"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
