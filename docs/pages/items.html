<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="robots" content="noindex, nofollow" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid rgba(255, 255, 255, 0.08);
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
                position: relative;
                z-index: 1;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: rgba(18, 18, 31, 0.92);
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 40px rgba(0, 0, 0, 0.6), 0 0 80px rgba(255, 215, 0, 0.03);
                border-radius: 8px;
                border: 1px solid rgba(255, 215, 0, 0.15);
                border-top: 3px solid #ffd700;
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box;
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px;
                width: 100%;
                color: rgba(255, 255, 255, 0.85);
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: rgba(255, 255, 255, 0.05);
                width: 100%;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                margin: 0 0 15px;
                box-sizing: border-box;
                transition: border-color 0.2s;
            }

            .staticrypt-password-container:focus-within {
                border-color: rgba(255, 215, 0, 0.4);
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
                filter: invert(1);
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #ffd700;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #0a0a12;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 4px;
                letter-spacing: 0.05em;
                transition: filter 0.2s, box-shadow 0.2s;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #ffd700;
                filter: brightness(110%);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.25);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0a0a12;
                font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                position: relative;
                overflow: hidden;
            }

            .staticrypt-bg {
                position: fixed;
                top: -30px;
                left: -30px;
                width: calc(100% + 60px);
                height: calc(100% + 60px);
                background-image: url('https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg');
                background-size: cover;
                background-position: center top;
                background-repeat: no-repeat;
                filter: blur(16px) brightness(0.2);
                z-index: 0;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
                color: #fff;
            }

            .staticrypt-site-title {
                font-size: 0.75em;
                color: #ffd700;
                margin-top: 0.3em;
                letter-spacing: 0.02em;
            }

            .staticrypt-instructions p:not(.staticrypt-title):not(.staticrypt-site-title) {
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.9em;
            }

            .staticrypt-cover-image {
                margin-bottom: 1.2em;
            }

            .staticrypt-cover-image img {
                max-width: 180px;
                width: 100%;
                height: auto;
                border-radius: 6px;
                box-shadow: 0 4px 20px rgba(255, 215, 0, 0.15);
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.85em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
                accent-color: #ffd700;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #0a0a12;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid rgba(255, 215, 0, 0.3);
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }

            @media (max-width: 600px) {
                .staticrypt-page {
                    width: 100%;
                    padding: 8% 1rem 0;
                }
                .staticrypt-form {
                    padding: 30px;
                }
                .staticrypt-cover-image img {
                    max-width: 140px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-bg"></div>
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-cover-image">
                        <img src="https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg" alt="Cover" />
                    </div>

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p class="staticrypt-site-title">ドライオーガズム6ヶ月完全開発ガイド</p>
                        <p>ガイド購入者向けページです。パスワードを入力してください。</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="パスワード"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            ログイン状態を保持（30日間）
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="認証" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "パスワードが違います",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e6facc2352e8f0e5be91092204b6c2c36e4ae956f5f11334cef927454a38424a5090b5c6facd8bd0e452bf021ef27867a69816c40517586b801841af0199807e690aafbb8f82af4f459431cb7c09b087fe2f399c4ae39b35a77bca9346d6d83d9d399d797c4831e5ac4745bce12f07cec2736bb31b48c22b645904580e129d68b08f443f0281d497bf2800ae892a7fff3ac3a1af9b1affcf74ef72e477358c52151f81a925b51d724a0fe8d04ef4946ec1ae373c8a4a7878bf57c1a564ca07e214ea1899b1d8ec9cf11884ff6f203025d5266beb42e3cfb6863558db51432a7b87111fc98140f25486ec4501e11051111b0d639b78cf1fc2eaaac0f0b0618a3e7e4046d81b7596375ecc460c30d1dbe1fff55142f34b0f0812a785a8b4f02ef98cb7d2e9e772bd9a0e15e8888f7fe2888abebe251632ff7b2d38d39b4882f3584dadb823f8828e0a03d1e8b58790594ac75a74e93ec0abc6aa56d63f166730ea89da4a3eed0a3c3add01f44ac168a0dbf8203a0427045dfcbf8e0275019dbb2a7e11f85f3e267faa01b252e01b89da70f8251f1fc414f9b934cc72482e68acb6d1f058939ba1dc92f97076b32efc5f6fb28613a5becf6963db0773672105d502984d9cd50478c69397b9e36097a6abc9501c7afaea9e06982a2776e6d47b99b2d187204fa94a52bf809136300ac3446f7ea042b5a7b0f964072cdf0216ce859c73df568e180c3f33a0c3107c61b30335aea80490245532412ca7890c0ca54868702c8fe1f2438b1554ea641195b135908fd454b928470eb513ebcde23721f23427c9083ae2e87db99471d1894984671ac8fc7576e23d375ddec7d6ffcc681e386891ad7387866656c994774b5f7bef6d2961204d09b22e656dc3678613081983e89be1dcfab0d3baee3f97fe4401a68acb3d7302630de9741099f21d57ff81d87e8cef729514671c4498ce62160af4c5e5765eace7c1683e2a3bc4e81b9fd2b24a9259fb467e88b3a15b40b7c3cd53d54649effa93bf21fc0eeb5f235ee5639bf608bbabdf7fd9282c9308bc7b2e66e8924eb7f31f88b2aceb8feaa037045408b4ee9a4238980c6662c55ca26d17269b2b6ff6d7f119215859effff69e00081fb171d93c8f9e30046cfbb0fbf8d77542ac55dcede7b777dd7abdf0aec2f54d24efefa57566bf2ec802e03e134277e79b44f8be076b134d9a03355ff57f798b2a394518e9d7097438f9f7f629d2a13a1aa2b7d323d6a1dddbcf72af3af3306e46c49aef7a9103f0e2c760decfc07d03c7484b5f21d63bd3a677c78e572ec7a7ac59fb62402b15f45d13b0b330ae0ddee8edeb8d3157be5cd48412dd155bbef1802acc195e576d8cca40ec744474bd7f81eec6c5965dbb7c7f3ba75d2668475d25531aad8ff212d5facc47f0f69fe232b91089aea7dc66dd77e3aa612e7f0ee0a0fcd289021430538cd10381b0a6c09c5abc20c724b5eeba195b07c6f8aafc5aba3bb509bc0493f521eac9094e106c1f8b651cd4fd7bfe6676f289d1d518dafdb016820a7a9eacf098796a29c182c3aaca85d0f31864e99cde3be1dc69c82e05facd46776f4fa20057851932df6d492a952d263205ef1ddbe8c553d2bc3e363cc464fdfb95a2f1a6ae71ea66760b6a8b27b1e47ea7d7879ccb201252080b7d27380490eb97f34ade4547a3e50f1ab0240e34a8693acd0544d00d95df21c16f40ffb504e4a50595f9daf9d103f152c46e86b175dd5a1ff3b9cb8c9f4a3a3ed562521d5e08b9fe2104fadb82fff103f9af48054b713cd8b4ffe4e290b86dad13b6fb72a9c79fb0c60d5eca4f00c185f247fdf3a444939194ff26cc460fe890fa9bbea119137ec2b2a78abc477662e6649198f81a26a68420bbca541907a598e2db13641138ae987b97418b9040943d31471112509025de1bc07c84718da25f9969d330a6428cb51c4348a25742bf7bbdd9847d871505a2c4f5e7a205b0a9a817a2dad640d208fae18dc8b02e7422b9b1bf6412e2786d5db7af02b07021fbe83fa4a004047b4a29f63a21382ec9d3ceff532e66dd48cc5bae902f3e2f49060d9325dbfe67a9348c6b3aa1b271e6252e2b22dffc5900a1bc26f9efce1ea4cd75473aac129739ba257dcf88562b7914195486ca7e3d779be17d62ef745f785841a4142c3aa6ad6c4be3ccbb0c6c8839ea897f2296f3dcdd48143f7433d4ac77f5a384bc7291daa081c021c047f33742f0e7613cdf98df651c1afeceb3874904835d230f978aac8385f293ede796ea6c10021d0d6fe9e15036fb235e40008096c5c8b09a887f79bc7b820d1465a252d3ff2861415dde86740755a95fadcec0966acf8c96a20dd0c775d16858044b50de673dd779d73f7230a8090ff42b51eca60b27f68167bc9c035f702e7fd4f57681bf7d3b0129736bef4bf5c5f9785a4c87a9f70409459f2bf30dcaab49c9ec9f817af41d1b6722a85db1175c89c68a4be1df6983b08c8ab1a344ed844bfb297aae6e6b1636ae1cbeee8766e6233d660f2b39abd924224e31672d881831c00a738ff43afcfe0804082de04d582b57d00959f9c229c6e59dbd5e3447d22ed6ff4420f7ce31ad300ff20e9c7fabc8d2e2e283dcb7695a3684cb19affeae0be27e3d2f24924898d96f7b05020fe209eed662a41ff2c5b759493430e296da22ec4a8f56b074ca5176783cdd0b5c45c92361cd2acd26965674eaee066fcf6b98d874532777e112fa805e262df4ba508acc6ec0df5efbf2c8630227d19679ec1a7ce2e8317fd5b4059943f9de678e794f52030bdd0aa884c38b0cb3aef03fc4dae02f961ef82f33be86f3c17e89076b9b94de205dfcb1874aa3c0c16a4c9bac1dd0b38822d3d9a68a814a23fcb6824803fd11ac56656bd22f06cddf2660900654cc0bfc70a00f4830779faa26e80cad2c52e4b211e8fc41b378133785f35a7efc4dea7d3967a246f53ffdc30655f00587fe8d08f297728c0cbad8c424577fd3cf15dd74fb6fc4794fb84934f08555279e5a37c0a958ad60235e304ce1e026576318fc3e5a5dc8131029c9d766e0cb56b9e0f480c32125619eb2f59cbf010ea60eb8a45c7852c45f3d5f56a949d0a32519b2e315a03a7f94fe859ccf5529cf3028085c8ee7b8dd99a7082ae35e8a37f4fbc5c956323ab9009762f6f983be655871f7459f04241cd48fe0b5b9c4db8956666df2922ba972ea91b556dd569979aa6eb13235db78d2ba7f8b8a2981130137288dab61e54d334606700865dc054291da2dc4223bac6ccec20b2cc58e595d310f9c7aa99cd074d8bffa6c0521e8084234037eda9e27953b1769fc611a5608828a16639402652f43f652b07e50771fdd5ad36d9c431c7a374184ce2d9462695f889130ed2274caaa940ba0da790a45bd30943fad500c36bf0612f926317c4abb374eccfc6d88e832221ec49581e182f2c90de436c1ff5f539affc591afab5643bfb7572d5a5eeaa84334ff2d9a173eec3ea573f5151cb97a8c8a29bccbee745d1f7cb0eb1dbdaf27c94ffe5248a523d2f3aaf209a2a7d69e602793fc00e1d3e3e7883e058e3a4636c57fc9cfff5585f15cfb01f98ff46ff459b63a24bbe841dad121ae96113f040443f8287c063b54998498df351c3681a205f5b1c2e61ae7ad5e1c509c5db7067965d3cea552d3540a4da26d4bc9537fdfd5d5e0c7f2f244feb73c0298d8c9cbbc6d96f3c3ae9637cb6627888990426fa94323fd3badc755be8e33cb9dc7abcf0a52e3e4e5fbf8ebf42a0e2c3b499e468d5b8dd0e619f15675375e2d6f8da1207501a3ab86bbd3966cb5b6791da2dfda600aed3ec545ee6af2b29d342979ea5cc17138347773f7d4230b330f35080f05c5049b05508090778a13246c69f1786547c9ebc419f7f6b69bb81a505117d9477cf83475592da919ebcdd977bb84c895cfead9145912367689fd59631fde704361d7e192a48e247c1577b5ba4170c9e966322d4e23a528fdb575088a5d65228510e1b830fcca8a94fe4c468aec573dd4c01748b13b98014e8d8dd895b0013afeffdb3a7d872c756979101f473533cefeb6e0c9bdde45c2aa6907ddf3724a8ce5461c370cfee1629426aa52efe463d7f9c4579387241f91070747bb5841e615a562e82107a9b8eb70c5f704ca2bf10c9d2795d0a5b1071a68ce86d0fd8c07daf14dd4afa03175a3e5fb13c7797f0f7ddc7759df90cd2db454c05daa2788cf837a852a3a789fea43797808ad53e369eaa02f28c695cb57a4bfc2d3d9c19602e2910b33525ba4755f1361d25cc06535aef778a8240937df3402ee9eaf259052ca1b70dff111ba6d07381b6d92bc8929083d5d84eab95d066fdf24f2eabc5d175e07f1667e3d6904423e4ebe0018014e57f551262198a9b74ccdff78a4360cfed7afa18e5202e4f42042d5ce0201f5d6fc838247568842205eb0f5a5c16316bde9669b1be43ce20601ed72d56d88a319cb7e6dd41630f70a747373a631e91b4148334fd2a2c06bd6594e36c2e5df5b4382bd5137bd4467b74259c2cec02b16110572dc16ec695cc4628a8009fb2a6809e700dedc2cccd92d1a0e2b7af9de8438830653ff65ef7e13ee1886a769cacf131a8a785a832072fc94ad68503d3b79fc3d83c69edbce46fb58a6394d2274e3938516f1b31a8a59681bb3660421cd72f00e7ec92fe2afe0a091abc0406df1df98f07c74a1aae5fadc519a81b5decb51f2155c77e7ea3b860f8e52b8b2e5252714872a5de73b5cfb9cf0804ad1b15b166a55c675d813479a601498bcf4268588c89639b017560f57de9c1b679b7b0946c7735e54a2374cbc817d4b79368eff97b0f92f6909fa0933e818204c9b43968e1798a8455611ddcc7672f89903c2de75f208a0a5010ce7780aa23850c217a6b6d6d65a52b935da3f0b04cef430251fe94c857d725cdb4fa6a83a64bfc3cc6da84b13bdd9c6fdf9f1c2f26c875e053c427acda835354226b5393deb8b0f47befcd1638982e388f8db80cbe50ff9a90abafbead5936e1e18c2ee560ffb076e1a830ee09cc04476b8cf321e728119a871bd737d6c166fd7d80461acbc7bf591c12a6990e0d74f55eaa569be298d9ea07ceaa921200fa180819d37d6a34b9b5b8df56c765792a3147f40d2da151160c927b6697a6b7f1077fc27cc35592973fc5e5fd76ba01ca82418b191598a0f40f8b07032855898ed566b6865232077d8cc128fa6bdd1a7eba9be6ed68b9f36b96953ae27a8d97d4ac936d74486a97133ceb23329431d751ad4b26cbf7ecb1fa7780380b20ede25feb1a608bebcf65fe4137f2cffe8f17a294da4b165e47718c6c170f3ba04c94d588dd93969d9fc6d8e6aa71e8a79835faabc58778b4e5ec3b47cc2ff2df6a01cf705ff66b00bba8e3c5b8bf5e14d4b0627644aa85d7a572061b7cd32a770d72ddae1c1acd2292ff9cab31d975ab01e59d7d7e845724a47da13f3f9f7dabd81646e81090cbcda1f7c6ceed5c9cc2f9af924923198ab00fa3f928bbc24c24542293fb79624987c6b320e3efa67828155abf8a9cf5e8fe56dc707d6c66224f1b7600c20bc84b41120c2755dcaec10eae1495a39af488ac46a337fa5c26845788cefa984f8408fb7698ccb1336738df58310f32abf4067c602e237f19c9f158b17cd690ca76c4f0b6ec08376ab1059bfb9f0cb0c6d09871ee82550055a5fef978cf389e96e1d964254ddf21fcdf37fa123f842ee20a599d4ea67aac341af4646c87f87c4ed3ae51ea96e5e58f6f4f4cd8c486229904882bb7436c7794dc3a25c0010d60ef3ad47bce29be09753dd39bb9d11357e6326ad57ddebea56220ebcef58a5dec9ba1556e63698df0f980e09a862fb0a433a536d9976f089898de1aa817ce6071d80f31bfac593b49d51a6b79e72180e8b9179368102526df9b0699b3e6717b3b3de091628aa04c458760c4890b0f2039aa0b617649451033f01fbcecc6289fa0f66d59282f38f1e9bd53795c025b35be92d3fa3b6e7a174af9d4040403b57f87d08401c5aa0117c121ecdc1af3564d1c4b0248014984481bea5fa0627ac61bf26d6bdbb9058b3a727ab0a7ab4345cfc8ffa993f4a5c7717c5b469c18da351e207807b377bdc1793f2034107a9110bec6129ca75c5116f23b1704e335e77034afc2fe12526b7a9bfb1f4f353c402b7505a36476064d9c51bc5874dce706a2a815591247d2cd7070aa87ad223dd0600e389a7abf7205af0e9ca4f10b7a6cb6e327c9df16c1832ce4976b480af880bc1f74ecd255e4f441a04cf07c4e3839d4e8abdfdd001785bffe4b138ee98a88c834e8b43828014e881f3d33bac35dfd2d88181991c1d457a448666ec4698390c2ef13e46943cb76f331c11a13065a07284eb80e0ce70ae062a1bb18109cde20b8fd2ecf9fef3b2a3f7c55df9e88a5fd82180f33946a305accdbf5ceb99a291624d3e2173c223dbc81718bc9042b1ccd7d2f447d95f41b05b447eefb821b7b1f9a0042b67ddbe4fd812d9444d5bdf141b3bab9e89a6b838e10318024fb0689dbef6dff436f32816ed5bdf4b400bdf5a0d261f284ae5d4f6876a8be96eeddfbf27cd605218defbc69e31a55ae9fc0ce12b5d228f6b9eff4a50141497d1c66c9669b3b29c18260a404a4180da04320d6f25e8772654eecd78ba9404eab9676cd9856499974c96fc5e0a3045e5ce4e25fc6be2fcc9f2c6b76e73785be8759087c5de2774f0ad7cabedaa85b595dfc61545648a9b7773de5d91bd8c66540fed9a2f10e9e4ba05b125f33da3d3c7bb5719a9e83ebc4d56d0917fb8542e94d46557abb1e57517d62098c913be72248d28dfa3ff98d80962b9a610f0087299bb71ca61ca351387121245b0e6b806256d412c88b453a27494f5f546fc1dda85c159a01e86e9c038ef7a1c2016987111287baff562cfa63c1fc945941a2b3f02a18c20a2c7c62165ad7148b51a1200774c30461cfa0fa6d50e7e860b98f34c0b818218e1fe89760e364f1410b36ac48c7f1396cfd4a0abcd6b3e5787e2060bf65ade7832a7a8147dc45faef7f733ec628a8cac6ab9de83d8db81c9f0a9bb762a698826dc3c6f34c681aa52f2226516c1edc960d6d881f6907586895e409f7279049d0c730f572f3925f61e92d87a2234510bf42a9ed1c098ae96241575654ba7f888fcc126ddf8bb04d5ce893b17555e832014cbcd241c369f4562a422e20226ab6ce4fa374dd5757199de9a29396e6b8ebaa56c645f6ab745303bdc558029085c1f8eabc42b166d8c9240a925c42efd4492bbfdd662bfc0465ec4799c1fa162c68fae136b940e716916eadea9828425cec06ae4743bd84d808f9f789f7e7e448b42e0784fc92070892d72f30dc9a2ad0d987dd1da262feab8db8bb8cadab794bd8d99815ed9bdfcb02d558db749b8cf808493c894375b7671adc02557bfc4fbf87933e94032353233f372ddb234f3bb565b305890e7523c760d824803d5f087d9f6838d7f617cf6602cc5a04e626cf1fc86e4bba920095bfab463f54a0e62443b1149331f61d5563e6be7d9eed15d1cb623019796d204db1e04a4c6a13cbae1bb06dc82a6b22a1e6f94418855c935dfabb9ff9532a6952afcf3439b31e3a5a2b7d7d1ada8220dd088dcb0efa890e2751554a9cdb6d8dd8ddf8eacb5eb4715646cc36a535c32d2d5b530e03d9f77376581d75e2291c18285e3452dc078beed8c0cebcca9afc1b00385367354f39d089b4709328a5f38b28c5f26657aa83cc065f9545e483a8ede76cd5fba5870cacb7999d1f9d1ca4a6ba3babf31ec4936ac1013a1d7f0e3695d73ae6fa7ec80e5df77d8565e36a4e4263e701a5dd7b68c8542e0683a010f7702b17d745179931cb14329a3c9bcfc9f4ff9f923cbf0b7866a99aefbb115097f884b6a46b86ab514d077fc8beabef953d1c1e163293ecd3394f34c809f90ebd8286cad9c144d576da8bdfdb939b02cfb32ac96caa7f17f0c4301ee908bfcf193c1bb09585226e0335288f5f9b025127be9e371c907c126d224f835ef90f18bfa769820e8d21fbd67df4a45a7be1a88c6c40facb2df7d87896562650f373122a8250614ea6429f2ac3fe141d0034c96297d51ee21001db7d9ac9b9ec4da5aceda0b0dd23e891eceb7d7dc2f6c1d499841f7556cdc6d0f3367949fd7f9bfc2c17e4415072fc6820ab6d77b2881f754da6a15d50c6a3d886f477ce89a60f993567d1e48ac6f5e00bf36226b98ca876f5cd2a5badcfbf2d4bc9d180c2f6dec87cbaf935937d748640f9580ee9529088026720d0a5cc96cf194dbde0121cd52a2ab0c6344f064d0ce1b2fbb3ee281ad03bf678b3083321b438e40bc6fbf276ce0528c141dd7c93f920f14495bafb8ed6c6a0c576db0f7fd2dd1ab8af8df255bb3102b836954ffdeec80271a3e4b0b8d4175e039a3a13401a5692e86f6bb9dc20a3662049371974c81b3762034b25140d5209292806f56483714673af46063347fff6795e2876968594b6965873d062a091e3bbe1a8270e1ac57d43a5bfeb4cc68da732c21e0010c918d9362aff2c3281f49354779c4e99080984cca3e0e3b117fddebbaea7a44332e8b749e414b662de6c4e05fdab2fbcab7acc3a0b05125e1bafeec28e8ae4073f7ebf4e882fa8f77185b9ed7c26c57098832191c0e60fb9364704a4d7219ab7c4fb03ec09da1a7111ce9ce11082321b0e42d375907394b9ed4dd01645045ee6f1a01d8e63c7823e383bbe72875be3497c65e312da6d96caf8e10c3ce27e6e8ea6ac7764b13773ee578769de058b6f1fbebb7d9e043144955ac728b4afb6f2a2505531d248f114b71e43c8b007db18b8f37535d9f37877c8c4a3a24275fc30756ba1bc1392907f09b706111b0d5dee04392176aa9181c64671b1b75e8aed7fa7654827609fa6837f23d9e2cd0b9e95350a0a388977bf2317dbf02da786c46897d74d8f4ea569c117e7a6c93d15cfee3e1e246b0288533493a0692287386e052b76ec3d480d9cd1841fe3bf43f788e007a11c6ec906ccbefb2b6ab4d3ea264cd8377048bee37789daed296fa49fca82425653f86992406dc8de386cc451523402f372de699abe445d12f86a461c69143897f3415a2b6f27bc07dd6a665a66e090390c711e8903cc7bb1543839db930ba113248d5385043917eee71750e16a8b8f0d7a98dcf5d3543ab6e1e3822e62e86c865a70e00b646ff6701d04d7882a97ca0d04486e8d8df71dd805e3798ab0cf80dea5ac9538f0a1827efd60efcd16836471041db33df2ef7cb98c311a93b06bbf3d8aece9cf3084cb436b37227723298dafe70982736aada49495c98be0ccbc896bb59f21790e2e3c5f52db1dd5e13a31ea7ed37fee1fc3a1f068ec8a8f03d752cf946cbfa3b91267f50364c305304d10911183f8cde55a241dc25521986300c7975ed391b89725fe2989b870e5dfad48ad19956094e1d85639ec94c21c04052a29553c5f44de5a196f65f00f4d9c2a2bed2707c19d37c93535e62f7f2f0df93bb63475853d6b15bdfb5e61e9bc0348785b7d173824e0c5eedaf46d61c7d1edf9fbb716ea773004087f02c5e26ac5308f22439b59dfde0b31eb52a6fbbabcab01ad7c7759755f21b70b7bf0cb591a8dc674cec8b45a12abb93a080fd18377b500036270fb57cd8eba53acf1771adcc3ce90043a3645330a6a4ecdb6ac4375931cefcaeedc67a2c7608e57330948196da0fd23fac8a90c817822566422300bf159d7a001395c208b67b66efe83d402485b4c52bc5bcc6f2aa0dc2aa4be1ae38d4bfe1a12c1774c905734d980f9d6a7c6d627112af361d14342ad5cae7092df82e38a7252284536bdc2dd93320d8eb6ab6ea493d8f6529953603b0b5911a5a1ca3d1d62a52412765adf0599398672af004f6a0acb74b9c4f919baff6f3e2651078fce55507e8107766fc7fd959dcc2480438deeb0ef78d4ce2cf80b476e3fc2ce06534e2bf4a73fd58ba008ad2270e9f3cf20c30d09008ca19305b58d486894c9882cc2a395a7667f6054acb6278a5f3a960d0049ad5fc1c67a3e7bc0f5363007b59964c4721cf54e7c56bb81d190605741b58e39ba4ac6f7896bcc60392eb64d865f0c9460499c5dff0760fa739436177ae6d1874ce9a4013e10d0b0ac142a6ab9ba42a9af4cef9cd2357b4582207f15e58d144717e7503ee9e163039195f8aae9b479e53fe545a7031d81609efaed11282e9f83862186784942d9d635cae6944f6b2ca544766bc01d117ce0da8f61e8201996d0219c33b6bd34c8860ddef4e40236ec3f4be4bbf4b817b5d95a40b0a0187d746c14f04cd836b3624d6d5b1e63c0556791ff52215abfda086f53eb48a0b0ae5a0fab9fdb62f4c20346d6552af3f2dc3d09c819aa94be6d8c1f2c91bb9db90426a73cfbc6a5770c979a4ef65c4ee380d28061530d48603e995259d7ddff1a37798f1527c437770789a9fd","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"50ad0dee8ce6b9dc1645f409ec5d5785"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
