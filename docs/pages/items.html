<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="robots" content="noindex, nofollow" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid rgba(255, 255, 255, 0.08);
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #12121f;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
                border-radius: 8px;
                border: 1px solid rgba(255, 215, 0, 0.15);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box;
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px;
                width: 100%;
                color: rgba(255, 255, 255, 0.85);
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: rgba(255, 255, 255, 0.05);
                width: 100%;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
                filter: invert(1);
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #ffd700;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #0a0a12;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 4px;
                letter-spacing: 0.05em;
                transition: filter 0.2s;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #ffd700;
                filter: brightness(110%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0a0a12;
                font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
                color: #fff;
            }

            .staticrypt-instructions p:not(.staticrypt-title) {
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.9em;
            }

            .staticrypt-cover-image {
                margin-bottom: 1.2em;
            }

            .staticrypt-cover-image img {
                max-width: 180px;
                width: 100%;
                height: auto;
                border-radius: 6px;
                box-shadow: 0 4px 15px rgba(255, 215, 0, 0.1);
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.85em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
                accent-color: #ffd700;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #0a0a12;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid rgba(255, 215, 0, 0.3);
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }

            @media (max-width: 600px) {
                .staticrypt-page {
                    width: 100%;
                    padding: 8% 1rem 0;
                }
                .staticrypt-form {
                    padding: 30px;
                }
                .staticrypt-cover-image img {
                    max-width: 140px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-cover-image">
                        <img src="../cover-image.jpg" alt="Cover" />
                    </div>

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p>ガイド購入者向けページです。パスワードを入力してください。</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="パスワード"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            ログイン状態を保持（30日間）
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="認証" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "パスワードが違います",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22f2f9c6c5ef93189c4bd33a8f673f35fcccb2653889396aa3f476499fdb4f1008a22598e39782b0ef8deea4aebd039c9a755375c4df76521fad6cba5ccf75e4048484dd4f20febad2276b5a63f4aecc5bdb0abe68031d41382b501e65719d6bacb9968c767c47aa884ec9917589bf58c67ed5792716aa5d8bcf78002cf71d73f8b551cfb831d0de0f5ac8d14409ab5b8ec32439d8fb015ec65053d8ae8fb0831bc441500ae9367f2b7b56ee51dfd21dc2e8c5ffbae624067cc2188170263f16b0c126fa09ad7e73e764982df53dee7be9199531befd86788b49314488e49bde1b2d6f43334e125fe3bc2ba3c047c7552bb36b963980462a4c3cf4372a1b104c00879a86e811cb300b5eb86cb79936e7fd13e42fd5609c0daaf81ec6f0aaa8692e316d4051846b0a113e8c942fda70d9d05e8c02694ccd434028894a3444971424eb4463567fd19b26aed5242d62c70578c9c767c459cadd9340bb6d709d9be53d30f8d89d689163b54e13765c4b00a89ce7658e11e3ef9c7d88e7f121c26caa3dd8f5b9eb09a01d28063a16966f2473c44440abc806ff381d9c8b3b3a9dd942b1e793f17dae94473f2f04e0d2f23515c2e23988f82d3c1336e05efff191a13791bfe9774eb43c7afd311c202b1865b3c5616d5950bbbdc426cd3bcd26a7c0a24b984512f01450dc4d80a4b75bf1a2f628c879cd29a227f5765cee2de35b1d21fb9ab809c07abc23799434950e8b8b774da22c05ec0908d46dcdd0951933cfa186fbbabfe91c79e52054e4ce6eeb6fe450e2dbb7b1007ef086350d08066fc82b2eeea4196ba8beae9306b4ad9d0dcc327e0ae7db65eb62e07d1c49468a8445e19edfd17e97c2d00fc15f6d15ff9cb1f3c52efb8dcba75f8df91e726bec2e1d02b1212f63120af1232ce8677b0ca65586276cfe4c4eaa4996f1f9ad2e51973aa6b77955ef1850d6df655df96e56329fae2c107cd1a532d7443f52cde4866af78c86d72ac27caca14406e4368472f2083fbe28b6498c15a19ed39992808e5eb5bc64ef7b64a786e00b35b45eeb48c89d7222e35d4442643e0f1884b07f23fccd5d289eb3359bae920d50f60d14a3ca60fc030893d0d723902c1afab4d3a85a84ecb15a0e85af3f9b5af358747e2732e68bd2df9f27cd694a364c70dfbcd08c7c663c9effe1b8eaa40769ee981aea1fcc91daf478a78ffb691b2cf708a839f87cfe5439a84385f45aface0ba4193e60598d5606de3e5cbd7ddb39ca018e6c2c466edc2e197f704b98a268d83276780e271f2b0a740ff9377d1a8e4a54d53473b356dbc696f19a23db876fbf275ea2b079ddded0c479ef4fa401919742a57b14989a8936c946b205bab0a555087f8dcdddc3f81bf1fa7824c47ad2c12a2893e1bdb629c179c1a393d7d78a27285710bb00f00e7a012170990755969b2df563a1c73e429d9350f0ae17b325dd0cee8b4f98883601a7fa2a0d2fa8e4e62e2822cdea627275e2bff57445002d6f81d89a1b7f23970acd04f82201da0d87ca7e45daa0b5c5af60d1096f8a10ba4f1069ce10242e51c5b0e007dee3be756d90c4e2481921e71734a91e0337b25c295a3fedbe4cff6a64c9297d9069e62d55e0e2842f282cabd9d6610fd63abf3a9fdadf59eff5c1c45254799c152573d4bbb65842d7d5110574541dc835e190602da43bea143655c54b03402fa970960e255761175db861c4f6c49422627e1cbebdceeb0819b553482f06df673324f80efea44997766ac91d0c7ee4b6089c5e0b9177c35a092c22cff029bccfd99feb5829b7e3c25c7ce80c7b76a2010f35cd26b05215fc800e1277e1f9f720f81a1fc348d05da15cd22fc985bea3a63df4b253f58ab5114d31d832277945353e9993db2b57a0bc4262dc441ef2b5094994effa877ffa6ece1a13639ff04fcf664ed41e7b33fe971e0c81eb0287f23ed9655ee3d4c7ca50a0035cb8e9986cddc35eef0e8e927c53721ad18bece6350d63e506b45bcd850b90854457a70fe19cba152cb2fbdf5dcee9588a5c3bccc885365cf9c8c3c100e096d968297a5172e258f6c3fea8592afa4b8a77a635d3926d5a984bbad80b506e2c812f311329f97de66792b4df61ea97ad6af068c938d39389fa935985b89478b28df56a82b76094800fc4152d2a78fd26fcc1c36ff2d0561c5d96689d69d2b0eb0247d262f3b5d9eab968b3a64264a5681a298f682e140f8ff240d9e0b5ad3ed030b00db8d2d1b9b9efba8914fc48b2fcc0334e14cea3f6509146538d1398c34d192a586953f8f2120b28b11c3a9f708f0a09843cde564a5122105d0442d3b13613fea7571056c416eb4ac473fc3a0c21e0354587e226394c8c1aaf18bcd7dea4eab9b685715ec58a6566d7da38569432349b7c953335d98406eb077441a30ec70086f47d6866b0a9c390df7f421ee3c56e106d51394a420227adf9ab9812080dbdcfa9d38bcf35b2beec41d3b7e767b0974e71e86007e108dfa133f70ee110ad85d794cd41073de5576eea43275abd2e719202f9a2675d24c96f0767aa47784e585864f982b0e197c7b04931002bc9d71d5b169271c866604b958b381dbe3e155d705f0ad3d184f9ccea7182f0ff36d11eb97f97adf26bafb7803176e0e688588d6ae5b0f554717f49dcaab9c8e86b498444762ffac461a8ae22c1a8fe7112f81e17998ef718022eaffc1e26d7f8fd25b0631dfa34b9f6c70fa0a194491663a66f3bfa3697c1c66cbfc555ce12034a2a56d5d37f2c05998cb4d02a0f3e73c1d0f66046c7c0e9090955db9fa30c3fdf5b0913cba112407ef1f04b50786f36de35cf3a8561feeed9d8eb72e7053b087e231057c71f4aed693387786448531566c8ff23389b688429babc3d84ad6501a2b5b88243ddbe49954739e65472762fa225996b4c79a0567f6d3535bc35ea833b094866bb8e659b9b603f5918453dbf5fa9b6aecdea487277695662ab34eb7e31f8b43f1a733367959e9d5f8b8b09328c3d41e1a6fbf8987726bec0bbee0dcc1bde0f9b90a7f3329a78605f70ed9f3f6a823d5696fb76feda5b04561c065b1264045cb248030fa3eb65d64c06d1371d2cfc3d106c064831ff9cbd5921d5f47a593ab8d6d57968f2b6948da38257acee5fd0f60757bc183b9629a92050054b95f8ee0b17916cb3cfc043f4ee7c14a6ec014dd5ac7059add82a3a298a66e84ea70261ed556909262178855dcb3c634bbfbcf24ace7156a05bef53b71094f51bd0f469518cdb9c89b3e2cd310e3ea575aa5c1e752852db080061e92ed765a35cd0dcabae72ab4c00693663ca5dff089f09ff373469fbf2b07004e0524e51c67ada33001e9de1d17f316d3b0fc26b474ddbd0f821c7d4d005618df8f69de4a3c6ea7a223a54fdf24dbf782e75b5d1a85541db7e8a75f8b4fbb90d5a46e1a0f53b71836aacf0395949960000b86d17749eb2187914d8274540a2c17b1b937cd1e18aa5cf77050c946a975aafea21e5c765a2c44b01ed37cfbd1a1aa03fbd67b90bea9c0c2ea5a5c9a494e4eacc7c6764e1952c0e3fba172a5c39e591042d56600cb2003353f91ae01433469222c6dd04b74cb9459fcb0ec7a375929f6f8256d97c674d1f71281de1c29523427755046162d8c88c7e9ef0e051750f083474fb415afb6ccaff5d3c7c0eff2bc612ce81b3452a656104e771b07730e871521c757b4ea1e708096111d84ce2e23812e896bb56944274144c8e40904c7e8be3ee1101a63bf013171e0eff7308ac01992ff9e4be9e7b4de42452414850956b7258dbfd47b980ca91525793793025d55f164b05bcb1c0f4d7b4d3e5cd27593600103584ec5dbb29dcadbc50f408095a700de7ca620070abe77f43d8f889a547b5a2947f21c43fb45447ab55e64f9757ee02d8e3aa65765a3c88c2b563cca65de6d575ed91ab5547e8aaac1ccb4ce7aabb57b295848b3a476e0ebf80ba8a95798a64a8e96a58c66d61e17d8ce440e2964644004838fe5dd439e9cc8556eef701df8a1f4e4c931e7ed69a03353eb03a282c93737da4e105d428a0c0b779457f9bca5823635457e375a0894ee4a5aa9a4f73131b7d90b40095200328532cba331bd0cbe5184b4edf60c520208fde9f4a4a2905f7e8afa1c95ac2242f13a62d345629d1ca630d6729497df21cd39439ce2a3dab42e5c0415129c19cf687919bb68201c669e5ee7338866cce03d0af6f73d358ae6dc7337f07c9c5caafa2d758bfa8f1c6e2f399f912dd48cce0a5533e79c182d552583fb10a2186d13739ad03b658ff9ef8df159f0ae07b77ec547acfd5f6ad4c2e33e0a80fc8935e03384fa9373b4013f60677b4ea633415e5edcc0b3bcfe74d9ad477ae5d8e4a8bde15d8b85c314d7562fa69483c241add2db5e8e3b4324fb9c3f1843fcdcde4a07f9d056de7fcf6a85a25400c990c6c4de921fc9c3c48a2714e2aa23e772d32895667a9f952df8cdac5c4b326af8e36052f75a32dd8500a7a36943a5fb07a21ff6bc8a97563d30bca9b7ae380db4248ece2a69c31d23e0d52c4f9d3ff087b3fcef4e37b2ccd66d3f8b76b971d2b69b7314c21ecbeb14e224f1c7c58a64c380b6cc726c14d05be35d1d3165d9e517dfc3248401c97cb4721483614a1fe5c2676611af8080f328d036c63713f70b3d4f0eae897f8b4c357976d342aed066f658fcc36b06d618f25135c84340f1893d6c59ab7f42563a1fcb64d55a8761897e80cc726ab6e03597eeaea113b979eff3d7328501d15a323e51b242f94b6fa06762a5ea3d0e3a16e75e0b820abfda7b87bd1df116974c3a8d531a329836f886863af3ba359c11ebd7de96b049c2e83d9abdb04faf14c367be83c7a82ca79a3d60164d803984a433601961db96b85c4f118e0cc533c24cb73f5a2c32d9c81f15ef16a10e8b9b46e82919d9943da559f45f61b878331295407f880c527245f43a7631e39792a232beb97027743bcab67c901b03a283235c01b1ad7a3695ae50bf7adc7259f5a0b3d4e46d423c727cb7d471f79640e0afa7b39fa8b76ff964aecb0fdb7e36eb6a9748d95c42d66168c02378ea288fb73d209206e4e2edf3a6250f12cd5ac95c84e22a2bd7c960f749f3982d47e4a870714e3e34716d4f44b413a49e90cbe8ec33c29e7fc0cfad0663edb389b7a0301888a4884e97c6b535815f8e82f29e9ede158d4f98aea24ad942a49bc17400174e420624054dd8f5b7bf264d7fe0b836d1a274742ab3eb8a5771308b9b72db6d7a32273ef22005f89a983d387d5b872cb0766a69fd05f3d14ac3dfcd7fc14620741baeea10d6517288f75bc67750c8a3271c56caa97ad8b8addf1f5286226a59cac8fd9e3af7fec4d59ad81c946858426dccc8aaa376ac53a507a6230f0cff2ae937e8d558ed116321b13fbc4776b902686a6fc635d3c4f9814732dbae195ad5aea8ea814de470bf5643b8c9c12920b3996623556606410a224f5d4ef06bc8a875956246262ffa37611a1c47da0be044dbfa3b0bf3e08e032eb8944e53a8553a5ff94a57704265c6252c831e738a30f97bed00b9ef89eda7084964b54931144e59aed7e59ce8925d1b264161b66f5dc095756d58e88407be6b6effaedd0f4318532b9ca64037144b24f243d9a58788948869e76c12d8a0e0cb41e2f02c4ab57d310e9d0778c3829f7107f65b2ce1fa14abc7bd450bf1a4ea1e48135cc15b97d0b4945cca5c38e0a395ca65e33cc380655b40e2b1ec25b55a9d694b2547ecb80b1d1209d08c5d8f76053c459b855d51a5774556028acb428b71cceefe54f4f8e34bc14194a19c47d862238552288a0a1f12ca776f7db24d7d08f4c7eb562a95c0d89a391e651a0dee66fc90f9ef6d30720065e6d0c0ee1056edb36dea965d4bfbdbbfbe13b47e72760e066deea8527396f6f58de46e4ca6f6339fb32dad9db67d634cb34615891f173c903a984557962e261c01dc2c7a438f2a1a99c36339e840f5cadcb0a472565dfd5eb53987a1fbea2e898e1f9396db237205fc025fbd1cc5c4c8a53356fe1a0159df58a37417f6899094699f65ca4db3913c54aa76a8ce233924fcb7490310e583f89d0e0408a00662f4b952451d90a412d61f620171dbfc3a8c3e826c86c0c2d779be2e4aedaf8b51b06ade47720e0e1e1592bd8b803e21e5a9b3d921aa5950869de37d547e18f1ed9bbc5dc4e8b33f538ad9ecb994d664f71160d68663e246a1d6b0359e509cbf6939d60a7f0719ad854dac86d5e2b26594d33364390abce682dc874fff3d22c77c36c857257309861a26153409330115593cd3beab167a2bd00d88e7a117f5b4a080525022a9f41317cdfa4240e522c74608e5bb7fec0bbf03da732cdbfa7edb484f150ae4d5265b77fde90874cbdf1c6f6481ae24974f70424ec96ba9291de70b96ce693ae93f5f2a3aa07a6de56422e774b44a9b4eba06b415b9f963190a9887074930e2a03e85e0f7f59f9244148734fa996f8313582e0a37ad18e080f78e3df5323ea9881f985e34630d15d86bf4deffef799fd86643feadb3c406e8a7f4736e9725110508a00544372870d6b1190f3c2f1b3e0a70521a8d7cf09f5a882a6c2eec720dabc9180f65c42e33569cac142a1bcfc08aa931637c12344b1c9e411cdc4e97660f5be366dbd21bb3045baf039ea9c9f96ff000e4d69ba60ae58c645bb268b35984e37d28d08fcf6c0295e193855f513de70807c9b708b9a9ee9de6c98d69950ae9ae663d4c43e03346e7d569f42033dfba35f1699c78923a5bd759aff75f70e50420ae6eeeb77c0b007af7fdde23a3a53eeb8d08ee17e2d9cac74172a26f34ddf89722174753137cf5a42e583e868be378903cf3f8209aa7e9ca788090e664810d040b768f3065972e3472acd171e15873a4fefc976dbaa17d81f76b2cbe8b56eff5a89daf76ad2d77787a30af2b5873e686f2a739ed81e20897cec2a96472ff476343dd499911869b024c485d3c2624f83346db66d0326f07c4aca9b0fa01c45612647d685ddb66235ed84ff7f4bc4b8e5270d54d01570e5c57fc6d6bce330483387d6d72f393a4342d3558db73947bf325c059dfb0b907ae5a8c090a367d468ed691df5f9aa47508c8c3836fbb478f850d479114833e1e250385d15624c781615274c25ba87710c7bec415f6cb396caa9d16a6b294510209e53dbdb6f0b1603b20bf77d7a7c89373263bb161e57082d1560c12152f6c443fb107ab2c25ebc93163be961a7ddb5771b371d95588ea983614d8ed969ce3aaaa14f32ffada804bedb61d9468e3acabd41ad0b9052350179577326c4ffa58adccd4c3c67ea37ff41b1cf42c4920be058de5d13ef8e6cbe502f4177546a41eb5232d88c79ef379c6fac8efb4adf7066fb10c49e9d3764679feff09d6976744a9661b3c429e16cd42247ea530c1f8c500ca4373304a0af9595f868ba2517ce37fc625235f47ddb548d29c5ad3695b2d4e46f133897a0632795ca3f4f2c2e9d7818d6bd43aa44a080f478d2dc168a38a72df498454f494ae3e0e4117879a169148b52cf36852dfbd2f4bb63783d493de74fa628d84a94e4907d4495f3c1b1c2151458aa01068709ef54d67da2cfcaf93e96bf8f4412401017dd24abe931725ef8515fa3f388cbe3b324c1dc5e7d87c9e06589d45fe5fa563670a251344e5c23dc7caa6dd70a3104cd67980490c17ab70996c1c3d5400cca53137190e4a7f9e4082a97ad6dd2630b98a1228a90d64b7304e16b1a1cb083ef2d3e315fbd881f9143741b7a8de4f770a831937b20474c558b75b97c325b80d03f0e7266f762d36d4c80aa040ea1fd9cd4ce4c56eb79648db232098227562c6d0145e5be2015e43229387ed425280024f4e88b28c186a427dca23e02bfc83caf0856f87def36f50b9bbf968e0d2f02162bc7aae5441ef6aade504791c28bfc6a1369e213e234ce47f3bf4c8aef062a34be45858b169e16caa06c32c55513c40887ef227a5ac537113a656da12d685d33f7fc21e1d4d58cf25fec8ac6390ed253f800791ef5cabe2e8782c5c4fa30bb25b8a12c4ee85cbf030f39bf34b94734eb99b7776b3752f131af938fd82059ce0b7325619980a16e7cc166e97c7a4bd558dfa54e10d976dcfbba0da37207d4d6f87ac1ac3428b32939efd36e5d2e01c8dd5c5f242d2e1c3d911e8b4c035280b381ac285a52907b7efee520e1123f011a668b7f863bd0edc607bba0d692b94c690b08a44f54c4041da960a246d28fa21bd61600dfb4dac1786df6d15eac8577c5d1d7a80afe6b13db51db49a623baa9cd65160808ad92cce4701219c6124b79ec30374bd49da710f608cf33dd0d2fec591d7257ee40e671a4bc0b5b796c3660c976963e5f5d11e079e3087310b02b3e44a53ff34562f52c995a7712e9fe9803464e7fc52f7ed1fb556480d0edf8b4304ddd95532e18737f1b294d1b0e2a8bb5a5e2ae95c8adf5230d763f357d3e481973aee1aee983e0aeb7437b0169a53055c97e8690508e08bbc24a49b9c8ccaa96aa0dd6f8c2a37b8d9a8b5ae5a201274d15f69cf4727c0ad53345fc2334bd22469a74f24e8e7c45e067db07dd362f9c30620b103a762956b5af5c2b41e7201557ccf887fb71005d0a8ab4553345e63b4f1157ba049aa05b2201d9c58c0999fb6d8a28882bec44a1e89ca3218da908bfc2946514f38e56a47ee04aa7ec45bbca4754cc1d4bda7f651c1f8beb811d830e315ada2e903b294b065fd482e922fdb03b781ac32350b63e40f4f7e1d7ed0aff107dd34a416e1cac3bb7646061a45fe1d586fdfc69d59a5f996eaae080cba72d86b4b8a3565059d30145a9318cbac3bc2afff325d0085d21573587bfa60b5b4838f9ac86631365a981e0a796302879d2921ed4573c90e7957def3aa9e0738e0b52b7362d480b923994fb469121815e7f670c92f5f6c627c88b537cbfc5a148f7ded8fbaa015728ac501dd8565a4b759deae98d777fd013127b768f76f1ce3b0de67cfb42a4a0b6cb1f8ccedf666107aecdd02771b3da3ed46d7c6124ef901ba0b647660f51366540ffb1a4a3097fdbbb3d1fadce22a49d9355fc108483c6de148fdabcf2dacf873745ae8690d48c287269198eea75320d9fe77bfbc36ed5af3f760ad86b04510705d3fc3f9edd76f0411c6dfa622113a87f61225b59f12fcb8b3da9ea05a00569f8cd2d908f5aa51e10de04d7be91c06d70615a7a7625940e9c7b758d018cb6738f242a636f76b84889dc55eb779d6adab11f61f6cef0310dec3132a51834f6dbde1d0e2af66079949a9bbbe6e3970a406ab9fb8e31881b0281b787e81ad634e61abab6749d29171792c0e4c71b5c7d4fa9ca591a47d030fb758646aef3f90c670526c77221a718680dac47d99e6b58fd5f1c6a98c5a229e81d9c3484e1c0cdb16ede1576e627cbe5ecfa16bffc1f33658747eddbd2d842d2e6ea7b57fb8bc3e2f7a8c7897a4f4ae07dd988a9789a6e5c4280b129bd1b491f3634769bc1c3d1d6f513243e6cd12376fc09335b9ac540658c6d5d0861cff05c0bc47af63e0c8d7f0f1ee572e0509b62b64b753a4496e60efbed6104ee0065ca6741014774c05698dcb821c827fc1d906157908bd1aaee2a451002c9d5233e8b2ed56c6a78b335dc0d476dd6578637378e753d98ffd28605ec8ff8c72b90d74bea861990b5771ebd2841498750e92df0fc82c8d07e3a2be1c70bae697cecdd5aae1151cf6a59d00caf23e8051fa036bad0267c01b91dc8e9facb294d9ffcc0681f88f8a1b95fdadd3afb9826cd401eb54b4c80e219dc53d2d6b6c48960c0f554bbe87a863b7eab7e7e80e1870a15ab8d98518140c7f91025edbac52705448ee90398c7ed3005263809458ff17c9bd8fc3a1f83c2a905b348c6e236de6fbfd68df4b3cc2d7f479d24b2b7e9ff9891efddfd73c5fd625825607072b68c162eadb4919f4c0ad614c2e2ce394012d0f5468a6110e0d3c9c9b00bf37169339a880e0e3faa20ee14c6bba26437f9afded20929c7a276bf00d4ec13a13ea3e41c30fce7aa9c3697e8d0d2c6255462a89c743f1479e94980057e24c9fd2147fe7a64a912bede73acaf5b4b5ea3e3083b1d5ab4de2f77fab54cdbaec7b7cebb43732234f2742764d3f9a8306f4234f171141d39b2fb6d3b786bddfd163db3e09e7a92232f95211fe224c32ef4db18a096123730aa68c11e6b8776cff286d97e2d51cf982aea13ed4b05d7d21f9a963ff906a72a0fc11aa928ef49e3ebb4488b5f446fcaa1d4caa90e74f97c09cb2873ce5ea02314fe3fd05b43f7882b97a1725b13ad693cfc5d8ecb2808a352290d9dce9ba9be2b40aba44ce35cc7b86cb515efd2245db966016792a6d1f4a318fd2c7f134f837774c2f0e26a006c5af304114616af7076da4bcfd2c4fdd70fc605b6b9c420224a14fbf15cabf8f50697a1755ee31dbcc7e0dbbf39d0196d21e3b17a51ee7cb482","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"50ad0dee8ce6b9dc1645f409ec5d5785"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
