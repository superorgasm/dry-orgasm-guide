<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="robots" content="noindex, nofollow" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid rgba(255, 255, 255, 0.08);
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
                position: relative;
                z-index: 1;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: rgba(18, 18, 31, 0.92);
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 40px rgba(0, 0, 0, 0.6), 0 0 80px rgba(255, 215, 0, 0.03);
                border-radius: 8px;
                border: 1px solid rgba(255, 215, 0, 0.15);
                border-top: 3px solid #ffd700;
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box;
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px;
                width: 100%;
                color: rgba(255, 255, 255, 0.85);
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: rgba(255, 255, 255, 0.05);
                width: 100%;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                margin: 0 0 15px;
                box-sizing: border-box;
                transition: border-color 0.2s;
            }

            .staticrypt-password-container:focus-within {
                border-color: rgba(255, 215, 0, 0.4);
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
                filter: invert(1);
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #ffd700;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #0a0a12;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 4px;
                letter-spacing: 0.05em;
                transition: filter 0.2s, box-shadow 0.2s;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #ffd700;
                filter: brightness(110%);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.25);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0a0a12;
                font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                position: relative;
                overflow: hidden;
            }

            .staticrypt-bg {
                position: fixed;
                top: -30px;
                left: -30px;
                width: calc(100% + 60px);
                height: calc(100% + 60px);
                background-image: url('https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg');
                background-size: cover;
                background-position: center top;
                background-repeat: no-repeat;
                filter: blur(16px) brightness(0.2);
                z-index: 0;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
                color: #fff;
            }

            .staticrypt-site-title {
                font-size: 0.75em;
                color: #ffd700;
                margin-top: 0.3em;
                letter-spacing: 0.02em;
            }

            .staticrypt-instructions p:not(.staticrypt-title):not(.staticrypt-site-title) {
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.9em;
            }

            .staticrypt-cover-image {
                margin-bottom: 1.2em;
            }

            .staticrypt-cover-image img {
                max-width: 180px;
                width: 100%;
                height: auto;
                border-radius: 6px;
                box-shadow: 0 4px 20px rgba(255, 215, 0, 0.15);
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.85em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
                accent-color: #ffd700;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #0a0a12;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid rgba(255, 215, 0, 0.3);
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }

            @media (max-width: 600px) {
                .staticrypt-page {
                    width: 100%;
                    padding: 8% 1rem 0;
                }
                .staticrypt-form {
                    padding: 30px;
                }
                .staticrypt-cover-image img {
                    max-width: 140px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-bg"></div>
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-cover-image">
                        <img src="https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg" alt="Cover" />
                    </div>

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p class="staticrypt-site-title">ドライオーガズム6ヶ月完全開発ガイド</p>
                        <p>ガイド購入者向けページです。パスワードを入力してください。</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="パスワード"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            ログイン状態を保持（30日間）
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="認証" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "パスワードが違います",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf4355079e3d5778c86768474600065c3647ada08179d27a69d4a73b82a4c7bed51599f33b58d1b7d7c14a562f166bfe4530b7fb5a308b2fee8bb348282c8a43e6b7488bc218ba4db696810b9809266754c60482397cd490c55d98f6e30bd1a920b65cf2d1940c1ae032ddcf08d924bbcf1310b4b648cc10d0431af2a67beafafbf317af7540ebc526651f61cc02b98166728be958ba57b74a6b2dbd7b299d6619f7c49e97e252162fae9744b1eb2106d1da28a97f18876abea5249e40590728fafe94c88de66e77039a1622239440811c08c17e06c5b6a390333abb479cbd619f938efaee2597d415e0ef7400ed76d34c717755c15b7aef77941ab791ab1e536076c706e2d837b5b18f7341f1ddec9d33456ce13464961499c96bf0c96010b55664026e684933456505648c9ff089943191862404b67d6373e2648332ed44a98097379ba142261b5e1f530a5604017681eef00c1b214deb66fd5c0d3e7e49d3fc80506c6b2cd5dbe5974de63ad3205c629f91cff29486fcb9ccf29d2a02e40b832801cbad9ba7f71414e8cc49515049df50e2723af3ad8b356eaef6e0f65673bf2336928844b3eb51b5a587210c75c413ff384c8c4b232e738cc6bc79681b69351cda1985646979d78456d33722bdc6000de2b3e7bf2f87663348163dcbc70f4100b6861fae1d9c25071480dd0c95d541cde1e18fa8b86059a0b03f236e67ebb8af482b6d44d85e641a7a296d6109be8139b5e019c0d3d966be1b32a658aa1d0408c025289c93c71bdc76d04c28ac3726ab0bba6e993b2329f39663d292d75cb1f427646299e6410d60d34f7509da8c679bdc6e4ca670bdb4dcd7bab7b609d42fac5ec13d4609d86bfe2131604cdb07c0adfb112d60e06977137267340859e610405459a653ffadad279b8f00a1549e49aba1c06937e92854f65196e4af08c0ca8a590aa51a0741c85b1dae88b701474a2bd3c225de83d72dfafa41dd193d2ecf4c74bc5e28f5f0fb799c13606e20437c0f6501c0f89551fada91aac9f2145d9848afccf7d4c6cf0506120fda1cb6e71c086d310bbde0a3f9e6c3da0173ae1eb212847a327f080b87687d28b1a3eac4f55d610ee34982e435b13c7eb98d38b3fd81fa1e0dab676ac48afa40a25ece5d408bd46e3fa501f8e67fb872a1baeda4b9a0653013a19d5a93b190a10421a0a706c30dc97702d51ed9833623b86d392dee9ca607b3971deaae15f8449675885b4b7cb389b57f94583e53cc0689c0eab26f201ddf694091e96e1ed6b55b813dfa7c045d178bcb4516115ead7cb69032d007d9d26ce456f8ededd14d503ce4bb0d3b9dfb1bedc2ed3d1baee563f434a3f9c4f9c1d8bfb4f5091f3bc65f2544ff5dcda9dade1b5b2c558f7cacfc08d89c527df14f0f6a126d346e3a4ee7126acb24e5ee5c3274a1539a5beac18fa82463eba27f138bc61d0a14b12130c395444e9ec60c98d734c32cfdd11ad772d83042dc354123d43b23fb4c8c01c0c89484830ff2491e274e920cc33741346441bc1fa588ed4b895ab0a81459186066b0405bd469ad5c8bd49bba25abfb97fcd207548e68538e6275a8146c897875c934d98f69dffef1eaa763e5368c74e2866246d4269708d22590ceb0091d90cc8716e8146dbf79da3b8a83101677f1510618b67c0a56c30083135c5c6fa680427abc4be946ac4ba3101f6340e0c0465501923c38d361a8665641a2355f90022b8ed88e348e148c6b169f37eb8f8a8c267cb37c696e9d6127d667259fa625efd07d98ad096bd28bc9977db1a48a44c65917480fdc6a8d6253976410860f92598393a0eb6bd7a62ff95307aa989308fcfa214aa8387e448802272540f13319b9f2c609b0af24cd128a28b39e78b8baf60f5a3f1ee595b414e8a3de247edc73a14c4552009d9669fd5dbd1a1527c86d324334aad59986215b3350ae3e111e5feee373bef4795e87eac42d22512a5a28d8723514c8e697d45b17cc0a02d219dd99bced461a6427b0c29c8f7f573f530b351b11c6541fe53a1a55e33f55c89d16784e8931f5bad6cdb0822bf12d7d419a622b46421a3c1112ee9336d1534233513ebd694f8b2bdc775921a3b4dd7a57d7cb03456c80f92cfdf488b9023911544c263a3664f8d6cd531de414b471c65ce455896dcbe6293e9f96f62a2a32e0d9ed42f924ccb87315b1d6311781b88c470fa4ddfcd8c395e3ab8a02176b2a23c60d859780cc42e13414a9b1e7972a0f45193c88f606d5ca31c1ce552f74233622743e78e0975f7287344db38562e6ab942b830c3a85c2c84f8832a6096a783d3fa49c1a58ba6fefb5f1fd9bb2973c75f0c92d952997d4dff2784a199e6d2d9e968703ac041cefa30886d686e7f886399705ff189f6bc468ae533e55ea95881c66f0d596133b20464ce59930c3a1f39ab7fef2aecaab0a839aadaae4975f8d3e665841e79bd443b426a9831466b9e289337147063e83924f8f30b6b8658ceffa7877aad6a8f8e8a28a745ce8af02a99e91dcfecd51ee5ffa3ade20b529efe4bb62bd5add709c8d28ac9d661a967acb7949218f5f104096dc9fd8ade1dc512a18fe1c7f854fdc06eaa177d3d66d7790e8869e78aae94eea87764d679de71392b42d50a2de825fb0fc588ec6441eb55d25f5122bae31ad1f4d2c4882fd98eea469051086e194eef29fe96b7f0b64e55cf68bb0593e7b044201f1e16c9303850b9252824b5a6b1ddece3d7718ecd09cbc7c9acf030b1d6447f50b0768ab28924c30fb2d38c862b1fec3325b22bae0edbbd62a010dacbf543a910fb88f14f76651c635044258fff6f50f4b688e741a0c374df343eb3654d4d668b3a21fa002ee7ab58df0f5153e267336c75fa20a6706bad8b7383012083c28f347aeb0496836164fc651d532662719006f5a45dc4cd48e04d2fe71c82c86189e1585047d79063cb57564b31f2ec7f5db6623e3bbeafa31a7277c189ce65ea37c239eb42681f8121e3a91fb29dc517919bcab2fa3e31c99e7b79c4caf440fa6ecf41a1797c07763b026ef2dbbcf5137df198ec83da65484db684baf5940bbe68c9a119970c66c1115df79db60fa98adb5ecd595ab0e7b97214801782959548c5ad92efb69b0024f9c57fb10b70ad09bd4ab3328faed92f9d33b9975f5c20fdd3ce2da9330a1960f1330d9bba40df9d2eaf2c5f849ccb6e142b0b0804f3bdda7bc6707be2d56d3da8fa42b619b66f5ad1d5b2e4e94227046ff035360047dc948c6d3f668b0baa20b5035fed07087da29e80e237d4def9e26720c5a0e240f7b56f898b10da508fa552ec1191d75ae13b2cd92c8f8aa7b83931bee875ac6a7695601505006a55ff61dd36a636863d5de4d9edc3827796adf3cedf592b307f52a70328431b41af87715f5e82d59cfea16e45726472bbe775d4b9c81bdb59096b69a2b1e717ac87ca10b424401515fe873e9e8fac9b081978da2492a460c4d9fe8ab5f4a8bf37c7688d4f46aced8a4840d23326d54b3bc4c1e5a4e5246322fdbcacc3a2401cc0cb1eebd1d47e8966e6cb730069a8aef136eacccf27b156ce605b85b3a32ce5e4b2b01287d15e5102e3ce393c5837654739aabafd15b98600dc1a1b14605f8246ad7b46bdf8f9c84a5ff819ee7c4a9c94171dfbfec723918fe160beef97011d03723bc5049195695260c5b5de59a0bc7aeab142292b79275742ad821f104d741d21c7f559f23dcd9c7fac6f3690ce77495b947db80559d69183883fdccd153d52421f64afff4436b6cf4bc71b2a6f4962df02eabc7b7aa7965ff20a5e6f1fdd565165a745a680c6eff3e8713b39ca08dadcf6ea1843ff582201e04c997d747341405072c899c05f47494397841c6bc7a254d76f3af15777cf2442e0ceb2b708e7e8365348c19bc7c1e3eb9117018b67e597fd86400be45508df68c5598326d60181a5820848467ca86bf505ee45c2db22f3a3657d5659e4aaa747e86b3c096416926a4ecb4416466b941a985e60ca13f4153637343ab2e27fbd00a41cc3ff326cfc700438a8fe706507fb09a1daa2f3acce9b3d1b4ebc377b6938a297677c804b0f270787a1cad1d5d3afd91c0661c4949d9a4df88ec1b7a486923dd6307a36bb948eb747e08e5c59716b6688ac6ecb9e064cda47cbaba44278f1534fd6446002456308b5ed81fc24217bdf69315a6d4186f95498ceee6d0847bf784ba00576245086fa2d4a08a6e8809f4b30a38504e51ca5fac93ebc465b27c5710ba49f8b58497d14e11bbaa6ea0bc3498e086d5fb4336848280a633e62de97186e09646ddff4c232dbc3f151b71ea90ee924e414639d40ebf84a5d8bec8a4a3addf9032042af66c4a5b79c50ec8e7696ac317d7d07a0c12200d22f8859b74365f31a4f41bd7e083b5293b89c970860eafaae0370169f067cb618e494d422cda44c078ae96e1ef6e04af266a8773cd5ecce5feea598d483d7a55508aeb323224c3c51ed91769c9412a635dc66f63db5c79f1bb6d5b903ab076a91facc88cdb71a0fee4213b40565f2a762ff364dc2426c539d9783cded5d692f1389decd43b0ef85bd76cf9dd9bbbe4fc819956ee0599345663294d95ec081562d73b418cba26f2e2dfb2df86ba0a2a4ba2dd204e2b41828652656d4495e6c314245a32a1c343efedcea772680d3f708eae57d97b29e44c59932eadc260b7ae5e285a37c17191e6026da14e9ff868a9d27eeaf69ec3c0db8336c138522a9d3f7fac704c7411330a2850b036d28862c5cd1c9a174e232f330533340ebbd07a9c20a48a430a82d1f6ecbe802f058701057f6ab416b9028abf20aa7818fd93c6e8d97d424de80c013937876bd95e8ef98b7d36cb87a9771b6a87d56067f64a3d4bf1c751946adbd1b6b7b8acb753888804dbd572c1dbc29223b301d4b8171297842d5c1e1bba92329f4adbf8398bace3b2bc064760c20a2825b2a6ee86c9d83a90b5b30aab8cf713688a225220765d94b4da1eaff6b0d900942505ba8dd99063ace478c24feb8d3b7ce8545f2933ff4cac06f0ed731def73ad0d25380bb7e7ff71d31b793230fad839d668612a9355fa83d7441175d9bf9d779300526c9a93c9fe20af2872a3a926fc29a4d77cecee9dea59dde7a0e8848b6484ad483f4d857b4489f566280c352f43fcbd8761802b57d4be1c0b2c9a077b72f2923a0494decc1cac0af230a0472132505ec8ecf6bc5aa7060a93edb3417aa2b317f8629d6208ebe79440f7469a9656469ce32a7dc91779329df9f96dd4fbcf8418ad54e7d94e266256e99fc3a5b152ed482a7c0d38d32a2422f11aa1a7b8a0538ec4cdc56775f1d3662254429bba4f4367dfca6a752661750661801052f6b41a75d44de5c8a8fd38d80014b17b3607d93012e18bfd2e3b5e9c3b109e7f6ba88ebfcc03e6c4a7383c194e21d8bdc8837c272d25137ad1a831d301c45c615b9f208273ba857b6f68b12f61ee89a933a30d2c858a5219259af2b168c3804b8e987c4841a791c5331897ab88e07d20ba03b0445ffbcc5e72f43b9778f6e13112cc7696f0c4c34450fd45ddb9846ef455987e010249c4c2f70353b31596cce44664983e44d639f2b033de8cf77b2f8474044919d05186aca3fb37820444b831a7d7a23ddeb31baf9afac97d95f7adb79c5e912c109779b38405c3d51e532d88aba18f21a5983296a0e830172299796b8682cce9e3ab7b105fb4f1f373822a77d73fde4dc4398e9926794c4a49b2801bd6b91fe9e1360fef76f7b505433440b8863791e48f9c0393b93528a77f3914e378c2a25e5005dc0620ca5e78e26492f8d03d87090f2f234229e0abea5e30d6744aefd1c86b0244cc702e728a742a6e874aeb8f90c5a4945a39298d55f1d45ad70bd97cef14c8def0196701f4cab9fe7e692715d7fc93e8571feedfd0f389645094f0d3bdc02a0ac64c9784e655c0d94278239e25c52df801309156ab6c7970c2d3530e8fe9b92ac8ffd71e8fe618f486362b7e48d6635040a46d343b148c84c515a8f8a4fa0e594a5f4270e7b97ede2584e5445c6963050ba0ae2a17fee872cb98917d3265912e24e160faa81404b5d18e0321b188669701e561a4604c6465fa70550817f0922719ff50fa031583450a5e86e3b5148ab2c0d62e82bd7c4be257a906933b68f7bdac30ac6a6f8ff54ed40b4b1345b3d63bba49fc4eb3ecfb42a1e7f01b3721ce2da705f82de16f12740be30786d5b0d66534e8eef8e9c6ff560b983ad22f48396d082648d998e0a046ef40dd69f7ef3b3f2d46b7be134a396e58a92e0973c78ded0462c3069233b9d0958a9940957d60bc818c63220583e18f0a594cc54216202f1c6e12be4e65fd897cf5cdc48111414b9f9396b26e5720f910b08b6aa1b5a74ae3d64b2b39c2f94da13911a715c7b5ea3d16521429f0f80e603afd3a1c0e728edf6d840e7502c89ce86a7c568e0f509c2d4228aec5e93d426b454f6a25d4d42379c185ebd83d939609f225cb8d14153d65e198292e78b772b0550fc1116e3a4beeaf95459752d506351af8042105ff44fe5b8484386e2e6604565b0008a76f545ae89363a0c348bebc9426938626c4663af04996d2af5ebdbb06d601ebfd39e569a9aca82c119b4f47612e597228ee2b44ff2e2aef82a75d3ca0308a0c29b8d6bf93a59ee12fee9ade1da97b4e728c03b924542c9d8ec742afec19d95533c58030b469be4c0e098324b6254ac58d03ca012c5a94a2534560962c2ccf2c105d5c14fa417504399f97f2a6b4c1842b471e8e4e55156353685d5c7faad5b8e478a3d1bb2218beaba5f4754c8ecae069a2cd682490526c0597b440385d7c0e67cb1a4d7080690c98834e98e0c7f85c79eb974c3cd1cadcaab77016546f05ecf691fbee755b461dff5e5f6debffe4bb201660cbd0d486e01def3fd748f6ee1fa0bea74709842b7d29b5d878910510c014ec07968f79fad4657563bd7d9d9c2fae8d185811f2906f70ed895c66e2c3196d66c8fee730f6d5bd01ee7626b7ad8bbcf130f5fcb9427094d35831b90ac65f2ebd1b79718c9bcb23621af71862cdcaec9c891526eb37a860b2d3b3c737605a8f7b59d059204fe67def31877c5e5937ec8b16b97194fa5f7ac290578feddc4ffcf439f50a93bf89ef34207e4802824f511da38eefab090f4dc2e55c4a8ec5dfac28d731b2fe9ea2a08dedecfb5225f52e94e43b1a8bdf4bb0ae94be1ee52c184313474df044fe730132212446fe69e8444b208d618f1be243b055155f712865d32038304f275e3b3abb80864eb6eaaf6868c8b550b0e3036502e0e3ae68dc5328a98ae628f1060cc150dd1e448a7e4a4ebf663fc4afe8145d9b69880a2f99ac73051847217b725abe1eb8f1622530a19ca1e8ca3cffe13f2b121d314c16e76d3e6081ed2e4531da0f8c38ed0fa376bb2b0cce34131d08b6044eb420be342e30053901512d640e4bddca227d4d8105e88b248b10a95ec560ac5fcc07932c46cc10d4ad5d373dfd0a7057f81552585c9b0650f66c68878a6813cec061a6e7505033bbf624693c44ee928c65595e22982e1aebcf69b2a36aee0c7dbb9447c01f63e55de0c66c2976fc6989b415de767859616fd28c087d4243c21e7b30b70dddbf0ad0e94e3df46a0e689ed4242aded2575e611d5d6cd51be63796100a6674123351a489fb69dcfd96bd47748e3ebc663cf1016d680347c482ad79520e3c69a542e159150ba7fd9f10bc886575c9d1d671d2c7b674580df94dccf97e9c9ac4e282681453c9897f49a992b58df2034c8655d81f95e4d51a6a88eb3a0c2c8f902ebc03df639bdb68edfc19d1d3a25a0f3829c97e6427ce632e1773a6fe17d950c58ccc50754ce19b6a55c60ed5476130b2e1b30303e217839b5bf6191d165d513e83022bf5ae6630f472d3a537fb78e99630330658e0d9087499f6266e1c1c3cf9d962fd0f97586e3eb991139eda1a7253f60cea58d590dbebc4db1951679ba1855126b16b5a3ae2604ee87f72a292968f4b71b37066e2de3a8d37d6c1b36df6dc67374ba42fc267efe4f44cf61363583e7b3fc56df15deb70557e1ea2033de82169565436fbd27a8323842b97d26d0a845d163d272fee5233961bfd9f623d85622f22d414bf76b5187032d655c59899550dd4175da28f0507c4c5249e7a9c64674c552021b82f95f0a6b1e2d941dca4db94a76ab25f30c3a613a24376d78ad6ec8afa2bca8f72bc82befb1ccb339056a8bfe0044ddd162fb09912490b9194e942c6b4099323372fc796049947a9094e74f7d19015fc6e7a05d68723cbe7f2887aa32aca321347d12ce6322e017d16bcbf965249f929a925323142d604b6d97c3834af61ea86ecb5c5af18326390ff2fb614c19eac7df62cc7320ab2d63547e33421095f8ea22c90dac94c87e7c3a75d69911d02ca9c48b7a4d411757015338651623f70f728f371ca5dc7614be0e16d9e3674d52a60c7b452f340d9db68f34fea1c733f9bf3d47720a2279041a4aa51c915bd8520b6d5dc165d2477e68ef00fcb1d93e4bf573302d19a5fdafd984dd2ccf049410f18c4c4a024fc68cf691b90e5def109a26390789278482cf0d46bbe89e92520fea08800f834e73286785e98df1c75de7c6dccd1d96b2c1e0fc827f676ff6aae8d9139651ca0dddd79c440339d4e7d63c8f2289d93cabb8701fe600487fdca8e4d44f0499f7fb2f221517173719d581a2f6ad8268afcd4a27aacdd7de9afdcc19bad1c8fc8a8406703f3e1c820b92b7e1063c1372afa6e4080045b9cbdc823ee51396666295f3ab8a81a9bf363f9579c85461b1f3dbdd0da996bbc662c2782f9ae744b8bf2b9a0917c7c403d8eb5ba1964a60a65a96fd0e6960071377494118e97dc006140a55e9e44c35248509d0a8f09b5f460bed33a7b144e658815bb7cbb8cf871e22a245989e9454f819d31799034a05a26360583faa19bd02feaf43b4d1b1d487c5f0158740fb366f8a741bd06abdf31ef9514b45bfe99596447008ace8aa02857eafc591b3d10d3bd50d3d01151c0d008250b2f8cabf99da4abb99cad358916f48aa74a97ba45a466e72b837b0d12867b5311bdb53d7c53dd286b273d72ff9e3077fd49012553c599a2c716935733dfbfe37b686feeb6fcde0dae5e615818fed48a4bdae17275532c8878a55188134dfee15eb3b3cdf794db6862cce866741aa2f5069dda9155984d4a7c3f3207b5df5c752017c4abae9ae47e5963fddd20335ce5417bc21f177d26e6159c5b46c526244b2f648b1be8dbb86149aa5de7d356631122c0df64831f604cffb2e67519ceeafbb41a7ff5304cbef8e6b6bd714c6c4b4e9ae1c0b7b373e598fc9e0b20a6e7a9215164a01321ff26fa97d526e5673335ea78b6e0eb047706492b1b64c4a5f1a67c2021db00c31207fefd4cbe74a03304171648938cefcfab331130f81179df047c8cf71f284f0d2279249e644b25d6b487e254c29e8fa8cf86593d65ade53355f9f4f194ce064fa0afe8f899358e837402a6663cca9e19ec9e935f54082039187cb3b09eef3d11b0c8fa1eca88f1003b75f5b3cb0108975e7abe9c53ee6e2ef8043d854009392ad5d0b840a4178acb8f4297e362f6fed4584bdf371e86c416ef284e320db76bef5413f33da0b0e2208dd4b50f75bd8668fad23a011b8d7d711a02b6f2535292a37e70e5816b5d39f7227ffcb9f028c8c1362a6364577d06ed72b47c0f2ff568d49fb2347bd23cba1dae9ffc43c461b15e0c88f032ca6c07b23d49017e5ba24e3cc3cb4e3f74eee6739d1816e155804e13d3e1164b83dbc235e1cf5b4e051fd588b295ba4e271272f800f023e1cb8d68b9f2e8632bbdab4921a17255acfd0a995a62a8fcdafbca4cbe03d7c85e0e48fa97e7f0f78914699d2cdead10f4d8307cb6bfcd4191465a167e22c39be35d5731dff537778ed8d73b9d92b0020d0f25642fe1d350f1a21e5c6fef2212e9c949418884a65d350f985fc350e0b80d9e2c9e70a138739828fdb1975e9f2a0b359c0352e0d3f8d0c00314035df19d06a1226f862bc97823154c10f84eeccfc4b1b8291f2978478aef129c0fed5c50a97bb8a3261bf7bd1c90ee8aaa0caed0b7f3ebb398b87a68a6371770289ee4222aec860027f9d3fa28731964019bf64b8dbfb73824dfb5fe4455234de652f84c92e138ad24e7b6ba200f497cf4c5fac1ba1096de1148e64a25ff6e4a2a3dcab93ee3fcad58b0ece553ad2a7618c926bc29294b4a60f855dc8a20a48e5ec8c96aff27579a1d64f9d5b3610583b6c45bae73921a9383cb6c4becc46b8180e5f777dfff55bbb001bb03abff725cb395a9fd3ce0c0acc9ad3431bc487e850b3e4b1c75ec21e39391111eb2c4c2e9c2600375396e09f09d26020bfa648b96bca59bdf53f8589f8a82c931b3914ca7394830c23cce38c758a74a6a092f43d17de09da2c0221a1ec7e87ef7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"50ad0dee8ce6b9dc1645f409ec5d5785"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
