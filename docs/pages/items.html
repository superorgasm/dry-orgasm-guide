<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="robots" content="noindex, nofollow" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid rgba(255, 255, 255, 0.08);
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
                position: relative;
                z-index: 1;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: rgba(18, 18, 31, 0.92);
                backdrop-filter: blur(10px);
                -webkit-backdrop-filter: blur(10px);
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 40px rgba(0, 0, 0, 0.6), 0 0 80px rgba(255, 215, 0, 0.03);
                border-radius: 8px;
                border: 1px solid rgba(255, 215, 0, 0.15);
                border-top: 3px solid #ffd700;
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box;
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px;
                width: 100%;
                color: rgba(255, 255, 255, 0.85);
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: rgba(255, 255, 255, 0.05);
                width: 100%;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                margin: 0 0 15px;
                box-sizing: border-box;
                transition: border-color 0.2s;
            }

            .staticrypt-password-container:focus-within {
                border-color: rgba(255, 215, 0, 0.4);
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
                filter: invert(1);
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #ffd700;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #0a0a12;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 4px;
                letter-spacing: 0.05em;
                transition: filter 0.2s, box-shadow 0.2s;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #ffd700;
                filter: brightness(110%);
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.25);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #0a0a12;
                font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
                position: relative;
                overflow: hidden;
            }

            .staticrypt-bg {
                position: fixed;
                top: -30px;
                left: -30px;
                width: calc(100% + 60px);
                height: calc(100% + 60px);
                background-image: url('https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg');
                background-size: cover;
                background-position: center top;
                background-repeat: no-repeat;
                filter: blur(16px) brightness(0.2);
                z-index: 0;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
                color: #fff;
            }

            .staticrypt-site-title {
                font-size: 0.75em;
                color: #ffd700;
                margin-top: 0.3em;
                letter-spacing: 0.02em;
            }

            .staticrypt-instructions p:not(.staticrypt-title):not(.staticrypt-site-title) {
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.9em;
            }

            .staticrypt-cover-image {
                margin-bottom: 1.2em;
            }

            .staticrypt-cover-image img {
                max-width: 180px;
                width: 100%;
                height: auto;
                border-radius: 6px;
                box-shadow: 0 4px 20px rgba(255, 215, 0, 0.15);
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
                color: rgba(255, 255, 255, 0.4);
                font-size: 0.85em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
                accent-color: #ffd700;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #0a0a12;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid rgba(255, 215, 0, 0.3);
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }

            @media (max-width: 600px) {
                .staticrypt-page {
                    width: 100%;
                    padding: 8% 1rem 0;
                }
                .staticrypt-form {
                    padding: 30px;
                }
                .staticrypt-cover-image img {
                    max-width: 140px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-bg"></div>
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-cover-image">
                        <img src="https://raw.githubusercontent.com/superorgasm/dry-orgasm-guide/main/src/cover-image.jpg" alt="Cover" />
                    </div>

                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p class="staticrypt-site-title">ドライオーガズム6ヶ月完全開発ガイド</p>
                        <p>ガイド購入者向けページです。パスワードを入力してください。</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="パスワード"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            ログイン状態を保持（30日間）
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="認証" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "パスワードが違います",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3707cbd5d19ecc6d8b98847f02a4cbbd81e06e9c972be5aca659e23b4c99a956d053fd650a184bd35ff737e739332d26d8eb3c8dfb475c43657f11b245807ecf510fe99d5588b9d9f609f5f2929b89442f6d2b4f6eb15b035cb34734b3090ea682b29897e8fedfc5cd97fb1b48df53dca6e7ed66e62ee1b5bb5fc927844208886e21783968a6ac3e0c1de2a11c6ad59e19a358f0a11084301333455e2944242c86eb3f28734b277f2abf67c91e5111f8aae0323544e4c0b4624ed7cd919b6b9dac5c823f7b7c2fa871c178296f854afe621b817a075d292b7c40b9417c63b3fc003cc6b1d68deb52b0199d39496c306d7dbe719e6b8b9cdc7dbe684ab21c7524a4963ff7a801c38d8d7243c98d0f47bffefa0d3fd5b721c3f56d74fe7647cc839202d9b4990856aa8bc5413cbd4d277e6c376620b0bf9493341ce922b29c8e80679bd512987c988e8f72be8e238fa31f9991620f49d6b93b4942d274ce74119c3e9fedd1b9b5a076f75a7a2fb7122c94574fbba0f9ca8685d6097f4849fc8cf148a6a70e69a467b61e12dc2b7082d859ba1c2b6ddf57af28d3d8c56f04cdc0fae0346fe305151785aefc5caaa734fe8394deb7f179a6114b63cd5f46100368d7a06047e7f3a3d67e9a0f2dd54899050f7dbd62121c87f0b3d4c698a411c9d5f567aa98cd489b42f2896335a9ab891fd06cda782e86d3e017a3988ee8d21fc07c2e072864e2ef8c7b69c03b5016a2a2a10f99c0968479cb5505c790b47a8ecec179a14539c2d68e547573b27bc3bfd6962df6aaf26cf5f41cc11b30738945f11c3f4fbe0a854974a111336c465732ef0d483aecfe5e4acd55c694f5da3985bc0077390bf31a43dcdc407473e913e504033d6430bf73f0d178e1297ea03f10cf6b5cd8092237c8836598b9eda6ef7e82dc8a3b2eefbb8d597102bdedc3207f13282257230b728277562388f0405b1ea6ccc583e8cd7104a4de2bb6c16b2811a54840841eda641ee7e8591ede5855053ad353ece8b613a7c379f88c4f61af9ab8c113d1fc31f4040b9ffb3404c46df1169a02ea237250517ea27357d525818353da21af0736b6ecf0ef001eb81b3a3c62dd7cff6e07abf9052435def3631701bb75021085e27cbafb24c98db85ab3506391c569b9f87b48b0c896cdf43a1e95bab609be03718a9ad838e5ee8f8232bd3c2c5f98a77444cb32c4fa05da913941d99943cf95dc93bf2524b41d01bc9e0f596260ff1bd02ce1312ac2a57da9729a9642101c9f0f9fa7f1f9c7ed2a26958818c6e4d6c3ee5b86899cb89cbbe420ab1ec317378a5f500dac8bd519de3db43d8059bd49a9bf13b1e68d0249598c3014d6e9c20ba09020309beb4124eeb64edabe3d93bcee4d0d6e55282e2bd8a83157b7320eba9e6984145a48fad9745a816f20d0011456df384a5c1e522951bc7a6a6ef27d11b7b0e40cbad8fdc78527a28b24efffc728ef7ce3e53aadede5ffc784a63200c987d6730c16822ca4a548e39f0126410b3fcdcb28f3b89c27b38a0ebf7b721ad3f9750438fd1f81690ca6836e2856016f4b2bbf38150ac33c80323445890dbfde31fab9087e0e8eb8b431bed9567c3e9a79ec0e6404e8cca6c30e4640628e96401a788c8bb27a609208c88251dc21caa712a49c39a24c6931647f5139c0b9aa01afd6597265d02cead75682024756d52a487b033e1073a62b69d0843956b21172dcbf85880ff3c3cc9375723e6aa331963b82eeec8ca378e8b1dc14b0dc31f9d8fb80bfe4a89a1b6917f5d9e025b3682a09563e027fd997548d65a854a292cc9ec07ac9db2117d3795031bc26623ccd35a414bbd69b8e4cd37248b1bdfa5b9225caf21cb911a854989ca53455c877f0c58563aae9dda4230066052f60ca9cc5d11b42c5fa61594e6085bfd41528bf658ff89438510b81b8010826e9d70e8f7a6a48d45c18fd5a8b0034633a411f9d5b892da4b93d4259c360ac67f17ed264338a5a39e4e5997787601b2903ab783e8008e5c2521738a675f12203e6d327567ae794a653e2bae568c7832760f677be215416a0bf5ddbb9b5512f01f00f8d363561211afb28fc48d47359c6b0ac1c3fc04d447d1bc6c84debb8ca901837d7e86aeae009f6dd1a3c14bf99684d7f945bfaec2dfda9e690feb93be18d4be2fece5092d8893909e1d55d5aab797a3148d65e9be34bb2c911adb3b4576c3a661e43bae9d0260f7612855570f4b79d1e341d7f9d045fc9560784538b551629fb99718277d2f2695ff1f4bb7679250a0ffd807d5250bc5f5d837865af5450461cca4588ce07af142a3dfc2435c9b82a37a3a9f7fd1b21241f5e28aba60718273363297ca1b914d7fa6ae9a231513f2716fd866b7f1bef970b24e6450b2ab1896276dd696045e0da4f6887c9115e22c92cef6a0430a307d274dbb29cfb66ddffdd00b67cb10120ef080f46368f1d201152ced4e49db859bbbfa671948db954a3ab3c6abf7dabcd9962fb74125a1f54a35949ea90e656a2e4bb0d21ac6bec7a47c91a84109071f06db7ac1535041e171a4cc2d08325e0c1c51dae26e36816668b3473ac991070cc4ccd81197fd275685392e564c3e690cd3e7a6b45f93a65dc53010f061c1e4b681d6eb6216541039c642186ec33a09afc4cd8031c72abf7fea61ff7aca4b77287f6546f1d96b05c44ec1183e504f6469ad392a47fd8ad4d184a3fb5b95bd91b5dee9e24e2f268c6564d34cf7ef14f583c2ebf0ec052ddbf940650268af77adbe3cccecac357b67e666a9f4076acc2aaca95dbbdf980c36dda52b5456333f53738e1685ef28e490d566edb76beede6262385a88ee7d756c00b464a8b40345876d5cedf8ea74695b1b0a5ad8f92ab86fc01326381831279cfd911d11eb91442442b28d11879883469f5ce0afdf31a8cd9ee99a7b0aa05f40db49053d1e054fa72c018f6f2fd63020fd11884ecabeed97d48a6bcc64ad98ceaa3e6e877650b38821577bf9ddf9bf90d9b94846caa173c19de53099575aa0d59f4c7dc113a3f65bf95f9b0942af25d68173cedddf1a087f8f3a34c9b66f89af650e19440edade242d5e5d3ed306385c725fa038ad9d86fdf92b1331f39c78bb5c14f8dc9600ec5563dd75517d9f57c6cda65f9facc1e9cc6674e0b2c3ba57343acce357d5f601cef8cc2de5af37f16f8fce6d48b2ff755afb4b9be7d77592f53f299a9f0a1f3ebaf51e7d22b1d1e58fbef30152b202fb0fa573e03c7fe56929baa505527d3ceb410361298f39de2d616fe9c5d16e7a3f2694f83995c070fdebecb055a5df8ba7d1305add46a91f7bb8e856c20643c2bb4b4f101c51b2b00ffdab298731c22d93f310dc5dd92aab3a6720693b0fe986ea01e576703b948bd97e6e2ffc876aea21cdbd325c8ef29dc23c528b59125fc986a48fcb6b81be21fc06ccc21a02bded0f045b1fad2372670b95d5770fe8add4cd5b8d23b21312f829391d65f0c34968d3fbbef3986aebfea4a68421d1f0fb6781534ddde5ea838a1330ac86571f04f8928eef0974ea16b8aeea8de7bf098f43f36f499d30320c5fbb6af01e21da5080f23383fbd071436350e4441440e1bd65a0294ed9a7017cf3f9dd9f30ab1aadc2ab694da383b44af1dd066e698e83c1f4d4a04b6c18a1bae6723b083d5e8c67ecc6c1df1981ac7a7dbd7b9d90d4f0a8585ee5a0c638b708ad516c113c676a891bba3ae540bc3bb9f5f72718ec2cbc4ae6ee6a0dbffc0b4547bc801999fbb5012007b617c9b9485a509acba2582c36238874794388dbef8096effc49c2c258dc655be97da8cc1c33935538bc00ac0a5d93742168a1c1ff5aba55a478fbefbc0ec8a5fd2d151519283068ee8e573a9e3fa756c5b239bb04146da12d462b67dd38cc7fc85be2028d907724fadbf228a8248b6c1fd08d46e00f918efd2e9b58463b30ef42da49680fdc11a3deb81c21f0c8adad14b75dc5bca3dfd4afa8247991edcc9dd6648e9c7f44627b6de024e84ab9f4a757ee081d25da64d0edf98509e9934f2cb0e9e1c773f0845a99d21b9d114373bd50413ff0fc80a527e7df4a4e2fdddb36b540610d2445e772a9a71a4b25b42a403f7fc38616c2b89ed0a83b501451f14bdb41cc23d7e36235b6be3fae11e2d0dd778a36637a20e985ee9a0b29072d1fcad891129bd26cf4d100f29a0be8f7fcb254ef7f274ed1836b7357774add5acb6733001140ae0ce7651df30829e687530fc4161f1847a40a5f27e6430bf618e1685e60fe19893a595efcd07bc10f670b2e32edcec20e2e2b88386e40f6f59428fdc5bafb42efb78d218e2528ab9dbc09700d8e3935beb9ba513bc1ea931d3419018b8cc541c2406faf805666ebbcf5b712bb975ad484b92ddc7017a63e7c693557dfe3360ec9b732311c1b3fb96bf360ffeddf0978cd1db7c3c2c42d58a0c1c48c3fdf3b690163205978ac52f5ddaf48f04aad06aef25da440e28d1f49986f252d6f3ebede5f1726bb8d2495d07c90b7026c33614b814cc99efa165fde605d01944a444a9ab1416977e3457ec338d844b450aedaf0c56697a870948ed119f947b35463809b2dd127ec37c7af6a686297234e51131a416ac717a847b61cefd78b34f10e32aeed42dd04e44afafce2befdde61b31fa1d042641e89144172f0302208c94201eb7163ea1879b757ad9d720e2ca105a7d4d547e8ee3cdc82ac845d358571dcf71b61c794a0921961cc8d935465c711a5e35d59a092b0f5d868a8d932d74163dd3367dc6406a049c75fac3c556b115a5b930fd6625055b8bea7032d3ae42e3633f7d6f39a68e92857e25f1b937e745bd4f33769bfbfb5f9d0ff8c92c76e6585c152e8cdf09944836f3253c9fdd18d91e1bfb24cb3cd5918f4f2df9f2c712529beefb35c519757dd8136d64ec5cec6457226f92184241b04b88808fb8b1932a82bf2e627a83c33b37330e1801a08de9e44a050c495e1adf0a5194ad5745c6df6c5f5b35f23b3154cb89e6a1f1588490ed4b1bbba2460618b4c4988a1dfcffd24f2ca67feea8d229f5ba0be36e7c5ef704b26f6088963e1f95f90993d1bcb4dd5703f72ab2084f184a3c0efc5f2f3714fc9fadeb33b8e744db851fc43741029abbcfb577baef83e4e7e458e45d2656855c6ac20904f56b7205aa5b227e01ac3b58fef0cfb73498ebc3b6b260e90a0ee047e2850e8e4732df1a9e53af7c0a75aea3ad254545d1467c198bae376421ea3874804a85ff2dc4009abed8886af42f6baf2edbc5fd39b5c07bf492bbe5109622bf482f95b9afb6e90a80fb6368da8d8ca41ea232657eadb093a2d0eed6163bccc5e1d24cdb3cee26c4d1f9811ce3c51983c2a421e195bc2fbc25cb44ac9134aa2b4fa74fbdf09b1ab42712ed25944230297e1761988f058aeb4d6e2ff04a7bf17a93eaa3347fc80dffad6298987b14cd03a121bfa5401383400db5a18d721e3ef4cd67c29d05357b523676c842a526ad542b982c638868a5b1359ff5138f14ff95636fe4b624050a9ce305b5d61633b48873d3e4ecfb06c9aac4ef8551ffaf737bb3b7cb36cdf42d24d4d6d51946d132b21af032e4fdf24c3a7b83828c5d2d4802a3c7e4850dbbd0e316dd2d31e6e24e2c82fd7b2084adba3d750cd695565e6c90276224eac1cecba2272e2ec085f83310c13bc544a17c3ed4ce3f342f66108c630e43353868b471fe72a17aedf64b5ba344c16d8f0a64aca3e586e79a23b2367ba13e570673ba5b12f8935be52dd61e796b83561b5ded5335cc5808a8044e4530162c1bc5529d9a474dc45cc49bf5873282e70573ceac520b40b9594b991bdf50045ae0172d1c1ccbb9c5059a8d9fa2be7305813dde9327976314d58dbe044a341403ce79ef8cdda7c1dba48ca7c1c1ab3517a1118973a030134320fab70d272124372683bd2bdd7bd9f0285d3d45c6a6a638ea2fafcc48a5f445e9dba0f0a9d8c10f3dc7112a3062a59be75c37e047b310532a3052a92d982fd255630b7723a8df4cd4b5d24a66410e4c6e44a63b76884405cc22040fa28638fe32e7565875cd7a243d3351a9b610d85f848bc673276aa2668c7ea75aa0bda8d65a8bb20f7d3d61243f4b6b4fbdbe38305f3e4d91c289ccda80c837da41df5783e48a38950b2d696ad54f27d5bdd48cbc14011e38dd1ccf3bede68c80bfb33cd935a49eed85bbc1e24c25f880f9f423fd9f10c1c2dacb0f67713361d5a0e1df16137645b8e957290803095b5ab916c9f576b149bb2c342aa3f648b09d28d52a1e479ccfb58f72a18adc69b718f8fda3a1fe860a41735aaef9d418aa8bf3af0a4d3e04d45f87708f9d595f434ab176af54f6dafc0c511016241eef4fe6a3fa52e08cc4185faa321a0c021b4c8f6ff8b285b0a7d73ce589070b79ea59c87b761768183398d62b908b304b44bad7f971b2e7c018591fa8de925064503d8dd09dd204edf70aed405729832c9543550528f2f723e0fcd59d56d561003e5c268b057d2c1f78e0df6dffcda463ba955515e158cad2da3a4658ca8cf6f886e2b26c3e5f429b6cc1307bf2cd05ca5f7d8d9f7d01605b9ae1e302fd7f5c031c58ea7886ca4c5ae3384a1a9c9ce19f2581f21ce2e1cfa7c8e11affb71d0c483a6022ecfb770edbe480d842e27c3fa39b068a5b621aa9c8754c73a83b48773f508ad2fc0ec374ec4f3a2eb382cc558854dd7ed76124288692d8eba6f6d9067e8e6c87ade2b8ddf6ff3e18e74fa578673c72bb55db58b08c4e3acd27f56d1fbf33048d00106beeb66da6389039543fc6a795ef098e432d6edac6a71d2b08e25819894b45703521115f290b26b2ba1640376961f524bbeac8177ba817be01d7c51b2a46a4a08d3286d5f09406f5b58589c054e62bd5eb8899a2804c1e63756a7f885f9abc3ed472d155f63c5f0193593c45e47a26cfd045f467e9ee3e073c5c619619524f323091ca975d5208cf85e8f3fc635d7dff96277d61a655c96d1edd772c3880751d2e96584c2656d78fa068c77314f1287e3aff8178a1102770c4aa8d9ca19d3256d456e108a86727efa0537d1ab0b1da816600fb79e03b0bbf18c850eae969d2864ed6a6181f45b9e7ea8b80c18914affb6b4c3679d1bfadd1ad9fc84042ff68087531336e303fbe905cd8d3d24abd13ce3d94c3b47398affda7468b8bde050bf56572dee74a85bf760476b0df3854151ad519114bdb8d32ea87b20b4e1ac367f477c8ac04ad7330b090e80267307d83245d4b795878cb7a4c3645a27543559104b568ec65212a6f7c844c713cd15c0759d0896671fde110170a9f3c6a843af5ba5a9e86ae4b5899f22e30dad5d7039124d792a248b683b9895a6e8759c0bd5955e04b27f9e7c110e231c3de7fba6151c7d99f2015cf2d1fe4b83bc72ab1a81708bb444c70f18824f279beb41320585644d8556cef7db0ee6d5c8c9e43de73d727f0aa26663da17a070e6e3ebccdbb8be8d8bc5cc816d282fae64095124796d9becd92b2a95ac7d0ac9dedac8d0031f63ab1882e544fda581b5a2e6b6912f58e165715b78bca4559ce307a34be08b73318da6f334bac31a0d438b89f39f3917ea972de65b6e9c0fd652811cd7ea237582c2eed87ac1d08147211946659e3d29e31c6678a2814aa4f5688955fe5f3ed348b8950eec604202336ad7c0a99804b0355f9336a51e99b8cdfc81f3ecf23569cacc6b08565899890f557629de9f9d5a2cc4a788cfb9efb6cd98760ee242174f83c26c2bee7320b7e6dabaff743cd165e80b8e8fd0641d2164e3a2167553dfabe08b499ac880b40506c7ca3503b2bbe89e17b11b2f05f07309c4ed861beb9e8cfce13bdde1119d975cc0756f553609870083b958e2e173e1996ac49e31a830670efed5aa9588789b2eb82695d635a42c495e250ff0fb093a6469054eae59bd0c864c31f05452621e4441bf894088fbe0374aa6b7b7d81d62ff84fdcd4b085c46ad430696b74f05d7e58115fbf0c274d9d7c322fa7c43aaa754e2e987a01b27f05912b2b84dce4d68bb080dde3b29077633fe6a34396b7da5f3aa43450adc1b9c74fffc688f201b1d550ef6d31e770dbe1d4c6b315ee821d19d422458c11e192b3e533eabbb992ef05fab85737097edd8e2721c6c60f8363b3900721aab5c6cab03dbbaa6128d669e2ee35813d1bb6e74c36cc46dc4734b0bdb31517c75d2184a3a75200fe259cc1a19029444f1dad45af6ef17d54cab5d83c4a69effb3e29e66376513ae2e04a5f2a4623a5d8489bc9cc02f25bfce7b1b44c3c2e836463227e85c45ce3d7cb39b515c83f398593b5ac35847e26b15297a2a07ef98a3ff8d117b2297e7f1dec009976aa868ac36c3bd31e4d05a5c46eec2be857845a25a4a77f4282876afb306f49ef4e045cc431d8fba5781ee382e90db7581fcf9e766b68ff4b6b801d57ea0ca5b0c500b57761f101ffac6479c38bb34ab35b87adbb54aa4ef77f1ce3819a7249a890b877ee8a7869b3b740495fe2b2b577af0da2475cab4491925c42a228452f8332c54eeea5222ec3a5cd5547591719d82de73cb7286408f44f952d9790840855d3ab544d1efe202e819c98ced3f197961b25c80304646526a0491a43dfc98f0d27ca197df44bfc971166e4721e69c181c12aa6390c62892ee22a763f3da808f7a48aff8d6dd76b52552011491e17187abdcbd4385fd59def26b068c2f4e07b8ea168dbcafca355636c10ed29995d82a450c9feedf1db86c7a4ce7e19271f7071185936cf14512a0d1f9ebd638262a15b28f314ef4c2f42118b06971af786c57bb6d1ab147b81d61a861cd112c85cbbcc048c9e9a8d783d3257e025aebf4c3303f1b107e4c58e39f102b9b0a37acd8f9c07faf80236f2f9dee8db7bfdf938077eb1111dd9ae2288f26772918b01583d3a8530b141ccab537dc7025456f1eb7bfba14371156d687cbde6a01a8806e5e709177152de5283552831e41fb85d7b90e596dab53d558dd12654a0e15320fbc34c261a65cdcc87084953ea820bb7dadb347b20a36a28ec18e0f7aea5a0460d88582ec88aec30a0b4955f0099e672e9862276a7626ec422c366eff93be4cd2accd8dd676aa016d1a15bec50a90702bc32c0e838848536b3e3ef901dc7cd8424df57c9b2c6c5e4743d2cf5738e713a32e213eccb508bdd3a80858533f1b15488ee3a2038ef6c652158af85597ff6b3583a17c1168611a2ee11a935f64e4a3590c77accf5e1c0fcb62d84070ed4b1d02a8e33f96af7f5a56c4974b1840908a21e9759e5f55a48dc02c2a70222b5031a0836ac2cc740bf9e0096ee3a6aed229c7b5dda30a60d0d81fd1c2284f3af34993d0eb1683da49442395d1d1d0fdfcf7a0170b44ddbff462d2b88bd94f0d6682d9620e867fb5d7e5172ddd4775bf22a1d9c4397e12c249db178fdbbf18663f5915e0dde6a41e6593ecdce86241cefc537918a0f7d26afad7b27ed4348ec5913d86c2d1923c7b0caf7fa49d7d8fd32ace2c24eb8c2deb1c1fa9de5b0a36b8e8e42534f44984e1a83c761d901edfd1c41ab0cf5a9265bd5575be434d0901de9bc99151dce2034a66ddfec4139e2eb799cc3564c3f517d41a54d100d847d137ba9936867cd88e728ad36a328e34119c499d0589c7778684578f4dae66ac4b4334cecd60ee31c18e32eb0088114eab8e1f456bb278041c68d3b364ad68e9c0ee9acb036ba35d0e177f73af52ebb81ab7139b31931a93905e0d185e259093d313c31ac48404aa16066cf5d28db85769c3aa7341dcf2d4c0f8832da6423939264ab72ff7187dc3d9be725237540d6a79c0abe183bc32409b431672233b323cbfd8203577f0794ab46e28fc1dc08d34970e22cb692d8517d5fc97c7ce2d76fd1e1fefc2c7da2859aeddffdf8d8c89a98fe06dbecfb89254873144dd135a09c00943b4a959907bf3dddcf232e285abf0d3fd5e138d074e30b9be4aae5fc13e2ff1922857ee75e4c26fbc9d0e3c545da4afe0236480436490da9a0794685746bb04cea6c5f6a262faa3e93f89afbf096de0e237ea1ec5f530e88bb2336ad5b40c71561c9c60451b0ee12b0644a3a5b8249bb64704181cfb1a9d776ac7b00e114182a49a558db1e77a8b6a745679a02a749f00b665e6e5498cc232f4e68f4e88a1ebdf0223faa7315272abb4a4275aa6b615c12f24e94d9bcb44de6344182fe99c28d54a87ca416f4ef394a7b89b05c03ef8ce52e6ed27091a0d8ee1345b6b57053c15782e1eab8a95689c394a13fa9db1edd64c22a9db81c924737ac7d2bae38c0c1d7d56d9e0f7ec709efa41a1daf2ba8393744f9ff36f88edf172d69245c76f85601a700ff181f62ac39cc476d3a890f4585d36ac4aa00a0c8b7716a42c582a734dbcdc009609bd0d5a9b54185d563fac1c8fd8452004ecebc7fd2838f21d441b473fbf860584637eca8af790cf00c4be494469050d882caa6706cddf7d15a033b011f13","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"50ad0dee8ce6b9dc1645f409ec5d5785"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
